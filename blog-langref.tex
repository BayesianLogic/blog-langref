\documentclass[12pt]{article}
\usepackage{mathptmx}
\usepackage{courier} % use courier for typewriter font
%\renewcommand*\ttdefault{cmvtt} % use computer modern as typewriter
\usepackage[T1]{fontenc}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage[algoruled,linesnumbered]{algorithm2e}
\usepackage{amsmath,amsfonts,amsthm,amssymb}
%\usepackage{wasysym}
\usepackage{color} % add more color
\usepackage{longtable}
\usepackage{url}
\usepackage[square,comma]{natbib}
\renewcommand{\cite}{\citep} % use the natbib style of citation
\usepackage[tight]{subfigure}
\usepackage{mdwlist}
%\usepackage[letterpaper,twoside,vscale=.8,hscale=.75,nomarginpar,hmarginratio=1:1]{geometry}
\usepackage[parfill]{parskip}
\usepackage{rotating}
\usepackage[hang, small, bf, margin=20pt, tableposition=top]{caption}
\setlength{\belowcaptionskip}{5pt}
%\usepackage{mathpazo}
\usepackage[colorlinks,pagebackref]{hyperref}
\renewcommand*{\theHsection}{\thesection} % Correct a problem with hyperref
\usepackage[figure,table]{hypcap} 
\hypersetup{citecolor={orange},linkcolor={orange}}
\usepackage{wrapfig}
\usepackage{array} % for the use with tabular
\usepackage{xspace}
\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage[titletoc]{appendix}
%\usepackage[page,header]{appendix}
%\usepackage{titletoc}
\usepackage{float}
\usepackage{minted}
%\usemintedstyle{colorful}


\input{dfn.tex}


\renewcommand{\optional}[1]{} %uncomment for published version

\newcommand{\blogversion}{0.9\xspace}

\title{The \bl Language Reference  \\
{\large (\bl version \blogversion)}
}
\author{Lei Li\\
              Computer Science Division\\
              University of California Berkeley\\
               \email{leili@cs.berkeley.edu}\\
\and
               Stuart Russell\\
              Computer Science Division\\
              University of California Berkeley\\
               \email{russell@cs.berkeley.edu}
               }
\date{\today}

%\Year{2011}

\begin{document}
\maketitle


\begin{abstract}
This document provides a reference for the syntax and semantics of \bl, a probabilistic programming language
that represents one possible form of unification for probability and first-order logic.
A \bl program consists of a set of assertions that jointly determine a probability distribution
over the space of first-order possible worlds (structures) definable using the vocabulary of
the program. In addition to allowing quantification over logical variables denoting objects and relational uncertainty,
\bl has {\em open-universe} semantics, meaning that it can represent uncertainty about the existence and
identity of objects. Hence, it is suitable for applications in which the existence of objects and events must be inferred from raw data.
The syntax as described in this document corresponds to \bl version \blogversion. This version implements many
improvements in syntax, usability, and efficiency.
\end{abstract}

\clearpage

\tableofcontents

\clearpage

\section{Introduction: Open-universe probability models and \bl}\label{intro-section}

The initial syntax and semantics of \bl was described in 
\href{http://www.cs.berkeley.edu/~russell/papers/srl04-blog.pdf}{{\it BLOG: Relational Modeling with Unknown Objects}}
by Brian Milch, Bhaskara Marthi, and Stuart Russell (Proc. ICML-04 Workshop on Statistical Relational Learning, Banff, Canada, 2004),
and in 
\href{http://www.cs.berkeley.edu/~russell/papers/ijcai05-blog.pdf}{{\it BLOG: Probabilistic Models with Unknown Objects}}
by Brian Milch, Bhaskara Marthi, Stuart Russell, David Sontag, Daniel L. Ong, and Andrey Kolobov (Proc. IJCAI-05, Edinburgh, 2005).
The authors of these two papers contributed to the first implementation of the \bl language and inference algorithms.
Full details of the formal semantics are given in the Brian Milch's PhD thesis,
\href{https://sites.google.com/site/bmilch/papers/milch_thesis.pdf}{{\it Probabilistic Models with Unknown Objects}} (Computer Science Division, University of California, Berkeley, 2006).

This document is primarily concerned with the detailed syntax of \bl, which has changed considerably from the initial version;
it is helpful, nonetheless, to understand the key semantic ideas, which are based on first-order logic and have remained unchanged.
A \bl \hyperref[program-section]{program} defines a probability distribution over a space of {\em possible worlds}.
It does so by means of a set of \hyperref[type-declaration-section]{type declarations},
\hyperref[number-section]{number statements}, and \hyperref[dependency-section]{dependency statements}.
These statements describe the objects that may exist in each world and introduce function symbols\footnote{Function symbols include as special cases predicate symbols (Boolean-valued functions) and constant symbols (zero-ary functions).} that carry information about the objects. (\bl also supplies several \hyperref[builtin-type-section]{built-in types}
and \hyperref[builtin-operator-appendix]{built-in functions} that operate on those types.)
The possible worlds are constructed from the function symbols and the objects,
and the probability of each world can be calculated from the information supplied by the dependency statements.

\subsection{Example: Writing a BLOG program}

A simple example serves to illustrate these concepts. Suppose that an urn contains unknown numbers of blue and green balls;
balls are drawn one at a time and then replaced after the observed color is noted. Color observation is 80\% accurate.
First, we define the types:
\begin{blogcode}
type Ball; type Draw; 
\end{blogcode}
Then, we talk about the objects that exist for each type.
In this case, we know there are two colors and (say) eight draws; by writing
\begin{blogcode}
distinct Draw Draw[8];
\end{blogcode}
we name these objects and assert that the names refer to distinct colors.
On the other hand, the number of balls is (say) equally likely to be anywhere from 1 to 4; for this we use a number statement:
\begin{blogcode}
#Ball ~ UniformInt(1,4);
\end{blogcode}
Having made these assertions, we declare and write dependencies for the function symbols
that we need to describe the domain. First, the true color of a ball is 
equally likely to be blue or non-blue; for this, we use a boolean predicate 
\verb|isBlue|. It requires the built-in
{BooleanDistrib distribution}, which takes a positive real number as 
the probability of being true:
\begin{blogcode}
random Boolean isBlue(Ball b) ~ BooleanDistrib(0.5);
\end{blogcode}
The ball drawn on each draw is \hyperref[uniformchoice-section]{chosen at random} from the balls in the urn:
\begin{blogcode}
random Ball ballDrawn(Draw d) ~ UniformChoice({b for Ball b});
\end{blogcode}
Finally, we say that the observed color is the same as the true color
with 80\% probability, i.e. the chance of observing blue balls being 
80\% if the true color of the ball is blue.
Here we use the \verb|if-then-else| expression:
\begin{blogcode}
random Boolean obsBlue(Draw d) ~
  if isBlue(BallDrawn(d)) then 
    BooleanDistrib(0.8)
  else
    BooleanDistrib(0.2);
\end{blogcode}
Having written dependency statements for all the function symbols, we are done.

\subsection{Example, contd.: What does the program mean?}

As noted earlier, the BLOG program defines a probability model over worlds. 
What are the worlds in this case, and what are their probabilities?

Each world has a specific number of balls, $\#Ball\eq k$, and thus contains
balls $Ball_1,\ldots,Ball_k$ in addition to eight draws $Draw_1,\ldots,Draw_8$.
(Notice we will use italics for objects in worlds, as distinct from
typewriter font for symbols in the BLOG language.)
A particular world is fixed by setting the values of every function symbol
for every possible tuple of objects of the appropriate types. We call
the value of a function symbol applied to a particular tuple of objects
a {\em basic random variables} or BRV. For this domain, the BRVs are:
\begin{itemize}
\item $isBlue_{Ball_i}$, either $true$ or $false$, for $i\eq1,\ldots,k$;
\item $ballDrawn_{Draw_j}$, one of $Ball_1,\ldots,Ball_k$,  for $j\eq1,\ldots,8$;
\item $obs_{Draw_j}$, either $true$ or $false$,  for $j\eq1,\ldots,8$.
\end{itemize}
For each $k$, there are $2^k$ values for the $isBlue$ BRVs,
$k^8$ values for the $ballDrawn$ BRVs, and $2^8$ values for
the $obsBlue$s. The total number of worlds is thus
$\sum_{k\eq 1}^4 2^k \cdot k^8 \cdot 2^8 \eq 282,135,040$.
The probability of any particular world is just the product of the probabilities 
of the choices made in ``constructing'' the world, i.e., choosing values
for the number variables and BRVs in topological order. For example, we might choose
\begin{itemize}
\item $\#Ball\eq 1$ with probability 0.25;
\item $isBlue_{Ball_1}\eq true$ with probability 0.5;
\item $ballDrawn_{Draw_j}\eq Ball_1$ with probability 1 (the only choice!) for $j\eq1,\ldots,8$;
\item $\ldots ballDrawn_{Draw_8}\eq \ldots \eq Ball_1$ with probability 1;
\item $obsBlue_{Draw_j}\eq Blue$ with probability 0.8, for $j\eq1,\ldots,8$.
\end{itemize}
The probability of this world is $0.25 \stimes 0.5 \stimes 1^8 \stimes 0.8^8\eq 0.02097152$.

\subsection{Example, contd.: Evidence and queries}

Once a model has been defined by a \bl program, evidence can be
supplied by \hyperref[evidence-section]{evidence statements}.  
Evidence is supplied by asserting observed values for expressions.
arguments (which may themselves be complex terms). In our case, we might 
assert the following:
\begin{blogcode}
obs obsBlue(Draw[0]) = true;
obs obsBlue(Draw[1]) = false;
obs obsBlue(Draw[2]) = true;
obs obsBlue(Draw[3]) = false;
obs obsBlue(Draw[4]) = true;
obs obsBlue(Draw[5]) = false;
obs obsBlue(Draw[6]) = true;
obs obsBlue(Draw[7]) = false;
\end{blogcode}
Given
evidence, a \hyperref[query-section]{query statement} indicates a
posterior probability of interest. We can query the value of any \hyperref[expression-section]{expression}
by adding a query statement to the file. Each such statement will cause the inference engine to be invoked 
and the answers---probabilities for each possible value of the
expression---to be returned to the standard output stream.
%%[[check: is output always to standard output stream?]]
\begin{blogcode}
query size({b for Ball b});
\end{blogcode}
generates the following answers:
\begin{verbatim}
Distribution of values for size({b for Ball b : true})
	1	0.07696467881871667
	2	0.2749155437572819
	3	0.3066400745347743
	4	0.34147970288922114
\end{verbatim}
\begin{blogcode}
query ballDrawn(Draw[0]) == ballDrawn(Draw[1]);
\end{blogcode}
generates answers
\begin{verbatim}
Distribution of values for (ballDrawn(Draw[0]) = ballDrawn(Draw[1]))
	false	0.7070034886998044
	true	0.29299651130018706
\end{verbatim}


\section{Syntax description conventions}\label{convention-section}


In describing the syntax of \bl, we use the following conventions:
%%[[not currently implemented exactly like this; need to fix the latex code that does coloring etc]]
\begin{itemize}
\item Keywords of the language appear in bold green text: \blog|type Ball;|
\item User-defined names (e.g., {\tt Ball}) and all literal values appear in plain black text.
\item Built-in types appear in bold red text: \blog|fixed Real pi = 3.14159;|
\item Built-in distributions appear in plain blue text: \blog|random Integer N ~ Poisson(12)|
\item Logical variables appear in bold blue italic text: \blog|random Real ReportedAge(Person x) ~ Gaussian(Age(x)-Offset,Var);|
%\item Generic placeholders, to be replaced by actual names or expressions, appear in italic magenta text: \blog|type type_name;|
\item The dot-dot-dot notation indicates that additional elements can be added, similar to those preceding it.
\item Optional elements appear in angle brackets: \blog|if boolean-expression then expression <else expression>;|
\end{itemize}

\section{\bl Program}\label{program-section}\label{program-section}
A \bl program consists a sequence of statements, each ending with a semicolon(;). 
The following kinds of statements are recognized:
\begin{enumerate*}
\item Type declarations; 
\item Distinct symbol declarations;
\item Fixed function declarations;
\item Random function declarations;
\item Origin function declarations;
\item Number statements;
\item Evidence statements, and;
\item Query statements.
\end{enumerate*}

Type declarations, distinct symbol declarations, number statements and their associated origin function declarations serve to populate
worlds with objects. Fixed and random function declarations introduce properties of objects and relationships among objects
and define distributions over the worlds that can be constructed using these functions.

\section{Lexical tokens}
\subsection{Keywords} \label{keyword-section}
Keywords in \bl have preserved semantics. Currently there are the following keywords:
\begin{blogcode}
  type    distinct    fixed    random    origin
  if      then        else     case      in
  obs     query
\end{blogcode}

\subsection{Operators and Punctuation}
\bl supports the following punctuations:
\begin{blogcode}
  ;   {    }    (    )    [    ]
  :   .   =    ~    ,    #
\end{blogcode}
Note \verb|.| is different from \verb|.| in real numbers. 
These punctuations are used to separating expressions or statements. 
\verb|{ }| and \verb|( )| always appear in pairs. 

\bl supports the following operators,
\begin{blogcode}
  +    -    *    /    ^    %
  >    <    >=   <=   ==   !=
  !    &    |    ->   =>
\end{blogcode}
The semantic interpretation of these operators are described in \secref{builtin-operator-appendix}.


\subsection{Identifiers}\label{identifier-section}
An identifier starts with either 26 alphabetical characters (\verb|a| to \verb|z|, \verb|A| to \verb|Z|) or underscore (\verb|_|). Then followed by any number of the 26 alphabetical characters, underscores, or digits. 
An identifier should not collide with keywords. 
Identifiers are used to refer type names, functions, distribution, distinct symbols, and logical variables. 
For example, \verb|x|, \verb|_abc1def|, and \verb|abs| are all valid identifiers. 
The first two can be used as type names, distinct symbol names, or logical variables. 
The last one, \verb|abs| refers to the library function \verb|abs()| which returns absolute value of the input argument.

\subsection{Literals}
\paragraph{Boolean literal}

There are two \verb|Boolean| literals: \verb|true| and \verb|false|. 

\paragraph{Integer literals}
\verb|Integer| literals are defined for all integers, ranging from $-2^{31}$ to $2^{31}-1$, e.g. \verb|-123|, \verb|0|,
\verb|7|, \verb|50000|.

\paragraph{Real literals}
\verb|Real| literals are defined for real numbers. Each real number is a double-precision 64-bit IEEE 754 floating point. The maximal positive \verb|Real| value is $1.7976931348623157 × 10^{308}$, while the minimal positive \verb|Real| value is $4.9406564584124654 × 10^{−324}$. 
In real literals, a zero on either side of the decimal point can be omitted: \verb|123.|, \verb|123.45|, \verb|0.123|,
\verb|.123|, \verb|-45.6|. Scientific notation is also supported:
\verb|123.45e-2|, \verb|123.45E-2|, \verb|123.45e1|, \verb|123.45e+1|.


\paragraph{Character and String literals}
Character literals are delimited by single quotes: \verb|'s'|, \verb|'\n'|.
String literals are delimited by double quotes: \verb|"hello\n\nworld"|.

\paragraph{Timestep literals}
\verb|Timestep|'s correspond to nonnegative integers, but are a distinguished type
to allow for inference algorithms that are specialized for temporal models. 
\verb|Timestep| literals are distinguished by an \verb|@| prefix. They are defined for all non-negative timesteps: \verb|@0|, \verb|@1|, \verb|@654|, etc.

\subsection{Whitespace and Comments}
Tokens may be separated by whitespace characters: \textvisiblespace, tab-character, and new-line. 

Comments are in the following two form:
\begin{itemize}
\item A single-line comment is a sequence of characters starts with \verb|//| and extends to the end of the line, or
\item A multi-line comment is a sequence of characters between \verb|/*| and \verb|*/|. Note any character after the first \verb|/*| and before the first \verb|*/| is interpreted as comment. Therefore \verb|/* /* */| is a valid comment, while \verb|/* /* */ */| is not because it has extra \verb|*/|, which \bl does not know how to interpret.
\end{itemize}

\section{Declaring types}\label{type-declaration-section}
\bl is a strongly typed language. At present the type system is extremely simple: there is no type hierarchy
and each object has exactly one type. Types must be specified for the arguments and value of every function symbol.
The types can be \hyperref[builtin-type-section]{built-in-types} or \hyperref[user-type-section]{user-defined types} from a type declaration statement.



\subsection{Built-in types}\label{builtin-type-section}
\bl has the following built-in types. 
Every such literal names an object in the world; thus, for example, every world implicitly contains all the integers.
Each of the following types has corresponding literals, except from \verb|RealMatrix|. 
\begin{itemize}
\item \verb|Boolean|: Boolean literals \verb|true|, \verb|false|.
\item \verb|Integer|: Integer literals \verb|17|, \verb|-53|.
\item \verb|Real|: Real literals \verb|0.2643|, \verb|27.2e+12|.
\item \verb|String|: String literals \verb|"abc"|, \verb|"123*456"|.
\item \verb|Timestep|: \verb|@0|, \verb|@100|. 
\item \verb|RealMatrix|: denoting matrix type. Please see \secref{matrix-section} for detailed description of constructing a \verb|RealMatrix|.
\end{itemize}

\subsection{User-defined types}\label{user-type-section}

Additionally, a user may define his or her own types.  The syntax for declaring a type in \bl is:
\blog|type type_name;|
Here \verb|type_name| is an \hyperref[identifier-section]{identifier}. 
For example, the following line of \bl declares a Citation type:
\begin{blogcode}
type Citation;
\end{blogcode}

\subsection{Distinct symbols} \label{distinct-section}
Information about the objects that are elements of a user-defined type
is usually provided via a \hyperref[number-section]{number statement}, but there are cases
where the objects are known and individually distinguishable, perhaps through observations.
Names for such objects can be introduced as follows:
\begin{blogcode}
distinct type_name identifier1, identifier2, ...;
\end{blogcode}
For example, an information extraction system might have 5 citations to work with;
these can be introduced by
\begin{blogcode}
distinct Citation Cite0, Cite1, Cite2, Cite3, Cite4;
\end{blogcode}
This statement defines symbols naming 5 objects of type {\tt Citation}.
Technically, these are zero-ary function symbols whose value type is {\tt Citation};
they are necessarily distinct  (i.e., {\tt Cite1} $\neq$ {\tt Cite2}, etc.)
and each refers to the same object in all worlds. In this sense,
distinct symbols play the same role as built-in literals.

With a large number of objects, explicit naming of each is inconvenient.
In such cases, one can use an implicit construction to define {\em indexed symbols}:
\begin{blogcode}
distinct type_name prefix[int];
\end{blogcode}
where {\tt prefix} is an identifier and {\tt int} is a nonnegative integer.
For example, the following \bl code declares one hundred symbols for {\tt Citation}s:
\begin{blogcode}
distinct Citation Cite[100];
\end{blogcode}
Now the names \verb|Cite[0]|, \verb|Cite[1]|, etc., can be used to refer to these {\tt Citation}s. Note that the symbols are indexed starting from 0.

\subsection{Array and Matrix}\label{array-section}

Array types in \bl include one-dimensional vectors and two-dimensional
matrices. Functions with integer arguments can play many of the roles
usually played by arrays in ordinary programming languages, but arrays in
\bl are nonetheless useful to represent values of sets of variables
whose interaction is best described by linear algebra operations on
multiple values simultaneously, rather than one variable at a time.
For example, the velocity of an object in 3-D space can be modeled
as a vector-valued variable rather than three scalar variables.
In such cases, distributions will tend to have vector and matrix
parameters---e.g., the mean and covariance parameters of a
multivariate Gaussian.

Currently, only Integer matrix and Real matrix are fully
supported. Arrays of user declared type are only supported in distinct symbols and symbol reference as described in \secref{distinct-section}.
%%[[clarify: what does ``partially supported'' mean? Better to say
%%that support for other types will be added in future?]]

Arrays can be used as return type of functions, but not as arguments of functions. However, some distributions take arrays as arguments.

\subsubsection{Constructing List}\label{list-literal-section}
As we already seen, we can use square brackets, \texttt{[]} to construct a List. Elements in a List are separated by commas (,). Lists can also be nested within other Lists. A shorthand notation is to use semicolons (;) to separated multiple Lists.
Thus, the following two Lists are equivalent:
\begin{blogcode}
[1, 2, 3; 4, 5, 6];
[[1, 2, 3], [4, 5, 6]];
\end{blogcode}

Lists are used to assign values to matrix, or to pass parameters to functions.

\subsubsection{Matrices}\label{matrix-section}
To define a Matrix
\begin{blogcode}
fixed RealMatrix table = [...];
\end{blogcode}

For example, a two dimensional array of int will be
\begin{blogcode}
fixed RealMatrix table = [[1, 2, 3], [4, 5, 6]];
\end{blogcode}
The following syntax in short hand is also correct:
\begin{blogcode}
fixed RealMatrix table = [1, 2, 3; 4, 5, 6];
\end{blogcode}


For example, a transition matrix in Kalman filters with Newton dynamics can be declared as:
\begin{blogcode}
fixed RealMatrix A = [1, 1, .5; 0, 1, 1; 0, 0, 1];
\end{blogcode}
An element in such a dimensional array can be referred as \texttt{A[0][0]}.



Linear algebra operations on vectors and matrices are listed in
in \appref{builtin-operator-appendix}, \tabref{tab:matrixop}.


\section{Dependency statements}\label{dependency-section}

A {\em dependency statement} constrains the value of functions applied to objects. In the case of ordinary programming languages,
as well as in the case of built-in functions in \bl, the value of a function applied to a given tuple of input objects is {\em fixed},
i.e., it is the same in all worlds. Dependency statements for fixed functions are described in \secref{fixed-section}. On the other hand, a {\em random} function
is one about whose values there is uncertainty, so that the values may vary across possible worlds. Dependency statements for random functions are described in \secref{random-function-section}.

\subsection{Fixed functions}\label{fixed-section}

\bl allows the user to declare that there is {\em no} uncertainty concerning the value of a given function; that is, the
value of the function applied to given arguments is the same in all worlds. Such a fixed function is declared as follows:
\begin{blogcode}
fixed type_name0 function_name(type_name1 var1, ...) = 
  fixed_expression;
\end{blogcode}
This statement defines a fixed function with name \texttt{function\_name} whose arguments are {\tt var1} (of type \verb|type_name1|), etc.,
and whose return type is \verb|type_name0|. The logical variables {\tt var1}, {\tt var2}, etc., are implicitly universally quantified over
all elements of the corresponding types.

The function body is a fixed expression, which may be
\begin{itemize*}
\item a literal from one of the built-in types or a declared distinct symbol;
\item a logical variable from the argument list;
\item a \hyperref[builtin-operator-appendix]{built-in operator}, fixed function, or \hyperref[external-function-appendix]{externally defined function} applied to fixed expressions.
\end{itemize*}
Put another way, a fixed expression is one containing no random function applications.

The following example defines a function to calculate the sum of squares:
\begin{blogcode}
random Real sumsquare(Real x, Real y) = x^2 + y^2;
\end{blogcode}

When a function has zero arguments, the resulting empty parentheses may be dropped
in both the declaration statement and in occurrences within expressions.
A fixed function with no arguments is called a \emph{fixed constant}; for example,
For example, constants can 
\begin{blogcode}
fixed Real pi = 3.14159;
fixed Real CircleArea(Real r) = pi * r^2;
\end{blogcode}



\subsection{Random functions}\label{random-function-section}

To declare a random function, there are two possible forms. The first describes a probabilistic
conditional dependency:
\begin{blogcode}
random type_name0 function_name(type_name1 var1, ...) ~ 
  distribution_expression;
\end{blogcode}
This form defines a random function with name \texttt{function\_name} whose arguments are {\tt var1} (of type \verb|type_name1|), etc.,
and whose return type is \verb|type_name0|. The logical variables {\tt var1}, {\tt var2}, etc., are implicitly universally quantified over
all elements of the corresponding types and may appear in the distribution expression. The statement asserts that for any possible instantiation of the
logical variables with objects, the resulting random variable has a conditional probability distribution
described by the corresponding instantiation of the {\tt distribution\_expression}. The {\tt distribution\_expression} must return a concrete distribution. 

For example, the following statement says the height of a tree has a Gaussian distribution
whose mean depends linearly on the tree's age and the growth rate of its species:
\begin{blogcode}
random Real height(Tree x) ~ Gaussian(Growthrate(Species(x))*Age(x), 4.0);
\end{blogcode}
The full syntax of distribution expressions is described in \secref{distribution-section}.

The second form describes a deterministic dependency:
\begin{blogcode}
random type_name0 function-name(type_name1 var1, ...) = expression;
\end{blogcode}
As before, the logical variables may appear in the expression.
Such a declaration is distinct from a fixed function declaration because, although the dependency is deterministic,
the expression may contain other random function symbols. For example, 
to express the fact that the observed value {\tt Y(t)} of some temporal process 
is the underlying state {\tt X(t)} plus an additive Gaussian noise term, one may write
\begin{blogcode}
random Real Epsilon(Timestep t) ~ Gaussian(0.0,1.0);
random Real Y(Timestep t) = X(t) + Epsilon(t);
\end{blogcode}




\section{Number statements}\label{number-section}
As noted in \secref{intro-section}, \bl supports open-universe semantics, i.e., different worlds may contain different numbers of objects and hence different numbers of random variables.
For a user-defined type, a number statement specifies a probability distribution over the number of objects of that type, possibly depending
on other aspects of the world. For example, intuitively the number of fleas in the world depends on the number of dogs.

The simplest form of number statement omits any direct dependency on other objects:
\begin{blogcode}
#type_name ~ count-distribution-expression;
\end{blogcode}
The {\tt count-distribution-expression} should be a distribution over
the nonnegative integers (see \secref{special-distribution-section}).
For example, the following example declares the number of \texttt{Ball}s according to a Poisson distribution:
\begin{blogcode}
#Ball ~ Poisson(10.0);
\end{blogcode}
As with random function declarations, a number statement can use a deterministic dependency:
\begin{blogcode}
#type_name ~ count-expression;
\end{blogcode}
The {\tt count-expression} should evaluate to a nonnegative integer.

\subsection{Origin functions}\label{origin-section}
The general form for a number statement provides a link between the objects generated by the statement
and the objects on whose existence the new objects depend. For example, each flea's existence
depends on the existence of its host dog. This link is expressed by an {\em origin function}.
Origin functions are declared as follows:
\begin{blogcode}
origin type_name0 function-name(type_name1);
\end{blogcode}
An origin function has exactly one argument type and one return type.  
For example, we can declare {\t Host} as an origin function:
\begin{blogcode}
origin Dog Host(Flea);
\end{blogcode}

In the number statement, the origin functions are attached to the type 
as follows:
\begin{blogcode}
#type_name(origin-function1=var1, ...) ~ distribution-expression;
\end{blogcode}
For example, the number statement
\begin{blogcode}
#Flea(Host=d) ~ Poisson(2*Weight(d));
\end{blogcode}
says that the number of fleas whose {\tt Host} is dog {\tt d} has a Poisson distribution whose mean is twice the weight of the dog (bigger dogs have more fleas).
In the formal semantics of \bl, the objects in each possible world contain their origins.

An object may have multiple origins. For example, in a radar system an aircraft may generate a blip at each time step; the blip's origins are the aircraft and the time step.
\begin{blogcode}
origin Aircraft Source(Blip);
origin Timestep Time(Blip);
#Blip(Source=a,Time=t) ~ Bernoulli(0.8);
\end{blogcode}
This says that the number of blips generated by aircraft {\tt a} at time {\tt t} is drawn from
a \hyperref[builtin-distribution-appendix]{{\tt Bernoulli}} distribution that returns a 1 with probability 0.8 and a 0 otherwise.

There can be at most one number statement for a given type {\em with a given set of origin functions}. More than one number statement
can be provided as long as the set of origin functions for each is distinct. For example, suppose some radar blips are false alarms
that are not generated by any aircraft:
\begin{blogcode}
#Blip(Time=t) ~ Poisson(FalseAlarmRate*DeltaT);
\end{blogcode}

\section{Expressions}\label{expression-section}

An expression can include both fixed and random terms.  Expressions are of the following forms:
\begin{itemize}
\item A literal of a built-in type, e.g., {\tt Integer}, {\tt Real},
  {\tt String}, {\tt Boolean}, or {\tt Timestep}.
\item A user-defined symbol, one of the following:
\begin{itemize}
\item A symbol declared in a \hyperref[distinct-section]{distinct
  symbol declaration} (including indexed symbols),
\item A fixed constant, i.e., a zero-ary function symbol declared as fixed.
\item A random constant, i.e., a zero-ary function symbol declared as
  random (often called a random variable).
\item A logical variable within the scope of a function declaration
  with that variable as an argument or within the scope of a
  quantifier or set expression with that variable in the prefix.
\end{itemize}
\item A function application expression {\tt function-name(e1, e2,
  ...)}, where {\tt function-name} is a fixed, random, origin, or
  \hyperref[external-function-section]{externally defined} function
  symbol and the arguments {\tt e1}, {\tt e2,}, etc., are
  expressions of the appropriate types.
\item A reference to an array element {\tt A[e1]} or matrix element
  {\tt A[e1][e2]} where {\tt e1} and {\tt e2} are arbitrary
  expressions of type \blog|Integer|.%% [[vector or matrix element?
  %% need to fix our terminology and ontology; also need vector and
  %% matrix expressions, types for vectors and matrices]]
  References outside the array size will cause a runtime error.
\item A numerical expression such as \texttt{e1 + e2}, \texttt{e1 - e2},
  \texttt{e1 * e2}, \texttt{e1 / e2},  \texttt{+ e1},
  \texttt{- e1}, or \texttt{(e1)}, 
  where \texttt{e1} and \texttt{e2} are also expressions of
  type \texttt{Integer} or \texttt{Real};
  with the exception of {\tt /}, the type of the expression will be
  {\tt Integer} if all arguments are of type {\tt Integer}, and will
  be of type {|tt Real} otherwise. The full list of arithmetic
  operators is given in \appref{builtin-operator-appendix}, \tabref{tab:arithmeticop}.
  %%[[check type coercion for arithmetic expressions]]
  %%[[are a + b + c and d * e * f and d + e - f -g allowed?]]
  Expressions of the form {\tt det(M)}, where {\tt M} is an expression
  denoting a square matrix, and {\tt size(S)}, where {\tt S} is a set
  expression, are also numerical expressions.
  %%%[[check size(s) is implemented]]
\item A matrix expression such as \texttt{e1 + e2}, \texttt{e1 - e2},
  \texttt{e1 * e2}, \texttt{e1 / e2},  \texttt{+ e1},
  \texttt{- e1}, {\tt inv(e1)} \texttt{(e1)}, where {\tt e1} and {\tt
    e2} are [[vectors or matrices]] of the appropriate types and
  sizes. The full list of matrix
  operators is given in \appref{builtin-operator-appendix},
  \tabref{tab:matrixop}.
\item A Boolean expression in one of the following forms:
\begin{itemize}
\item A logical expression: \texttt{e1 \& e2}, \texttt{e1 | e2}, \texttt{! e1}, \texttt{(e1)} where 
\texttt{e1} and \texttt{e2} are expressions of {\tt Boolean} type.
\item A comparative expression: \texttt{e1 > e2}, \texttt{e1 >= e2}, \texttt{e1 < e2}, \texttt{e1 <= e2}, where \texttt{e1} and \texttt{e2} are expressions of comparable types.
\item An equality expression: \texttt{e1 == e2}, \texttt{e1 != e2}, where \texttt{e1} and \texttt{e2} are any expressions;
\item A quantified formula (see \secref{quantifier-section}).
\end{itemize}
\item A set expression (see \secref{set-section}).
\item A map expression (see \secref{map-section}).
\item An if-then-else expression
     \blog|if condition then expression1 else expression2|
     where {\tt condition} is any Boolean expression and {\tt
       expression1} and {\tt expression2} are any expressions.
     The expression has the value of {\tt
       expression1} when {\tt condition} has the value {\it true}
     and {\tt
       expression2} when {\tt condition} has the value {\it false}.
\item A case expression
    \blog|case expr in map|
     where {\tt expr} is any Boolean expression and {\tt map} is a map
     expression.
\end{itemize}


\subsection{If-then-else expressions}\label{if-then-else-section}

An if-then-else expression allows one to use different expressions depending on aspects of the conditioning context.
The general form is
\begin{blogcode}
if condition then expression1 else expression2
\end{blogcode}
where \texttt{condition} is a \hyperref[Boolean-expression-section]{Boolean expression} and \texttt{expression1} and \texttt{expression2}
are expressions. For example, suppose that a {\tt Coin} is exactly {\tt Fair} with probability 0.99, and that
a fair coin comes up heads half the time and a biased coin comes up heads roughly 80\% of the time:
\begin{blogcode}
random Boolean Fair(Coin c) ~ BooleanDistrib(0.99);
random Boolean Bias(Coin c) ~  
  if Fair(c) then Exactly(0.5) 
  else Beta(80,20);
\end{blogcode}
The \hyperref[builtin-distribution-appendix]{built-in distribution}
{\tt BooleanDistrib($p$)} assigns probability $p$ to {\tt true} and
$1-p$ to {\tt false}. It is equivalent to {\tt Categorical({true ->
    $p$, false -> $1-p$})}. Note that the {\tt Bernoulli($p$)}
distribution returns 0 or 1, which are not Boolean values. 

Note that if-then-else can be nested. 

%% [[explain defaults: If the else-part of an if-then-else expression is
%%    missing and the {\tt condition} is false,
%%   then what? - Exactly(0) for number statement, Exactly(null) otherwise??]]


\subsection{Quantified formula}\label{quantifier-section}
\bl allows quantified formulas, as in typed first-order logic. 
Each such formula constitutes a Boolean expression.

A universally quantified formula has the form
\begin{blogcode}
forall type_name var expression
\end{blogcode}
%%[[check: can quantifier prefixes have more than one variable?]]
where {\tt type\_name} is any type and {\tt var} is the name of a
logical variable. The {\tt expression} is any Boolean expression,
possibly containing {\tt var}. The formula has value {\it true}
in a given world iff {\tt expression} has value {\it true}
in {\em every} extended interpretation in which the value of {\tt var} 
is an object in the world of the given type. For example, the formula
\begin{blogcode}
forall Boolean b (b => b)
\end{blogcode}
is true in all worlds, because the Boolean objects in all worlds are 
just {\it true} and {\it false}, and the built-in function {\tt =>}
has value {\it true} for both {\tt (}{\it true}{\tt => }{\it true}{\tt )}
and {\tt (}{\it false}{\tt => }{\it false}{\tt )}.

An existentially quantified formula has the form
\begin{blogcode}
exists type_name var expression
\end{blogcode}
and has value {\it true}
in a given world iff {\tt expression} has value {\it true}
in {\em some} extended interpretation in which the value of {\tt var} 
is an object in the world of the given type. For example, the formula
\begin{blogcode}
exists Boolean b (b & b)
\end{blogcode}
is true in all worlds, because the Boolean objects in all worlds are 
just {\it true} and {\it false}, and the built-in function \verb|&| has value {\it true} for \verb|(true &  true)|.


Quantifier expressions may be nested, in which case
the {\tt expression} may contain logical variables from any of the
enclosing quantifier expressions.

Currently, \bl's inference algorithms have no mathematical
theorem-proving capability; hence, quantification over infinite types
leads to expressions that cannot be finitely evaluated.


\subsection{Set expressions}\label{set-section}
A set expression denotes a set of objects satisfying a certain
Boolean condition. All such sets exist implicitly in every world,
since every world contains objects and every Boolean expression
has a truth value for those objects. Normally it is not necessary to
construct set objects explicitly, since the same work can be done
using predicate expressions, but sets are useful in two contexts:
\begin{itemize}
\item When choosing values for functions, it is useful to refer to the
  set of candidate values, e.g., as an argument to a distribution.
\item When observing that certain distinct objects exist
and constitute all objects satisfying a certain condition,
a set expression can be used as the observation (see \secref{set-evidence-section}).
\end{itemize}
As with \hyperref[quantifier-section]{quantified formulas}, set
expressions have a logical variable that ranges over a given type.
The most general form is
\begin{blogcode}
{expression for type_name var: condition}
\end{blogcode}
where {\tt expression} is any expression, possibly including {\tt
  var}; \verb|type\_name| is any declared or built-in type; {\tt var} is
a logical variable; and {\tt condition} is any Boolean expression,
possibly containing {\tt var}. The value of the set expression in any
world is the set of objects that are possible values of {\tt
  expression} as {\tt var} ranges over objects of the given type
that satisfy {\tt condition}. For example, the set
\begin{blogcode}
{(x * x) for Integer x: x>0 & x<5}
\end{blogcode}
contains the elements 1, 4, 9, 16.

If the {\tt : condition} part is omitted, the condition is 
assumed to be {\tt true}, i.e., the variable ranges over all values of
the given type. Thus, the set
\begin{blogcode}
{(b => b) for Boolean b}
\end{blogcode}
contains just {\it true}, since {\tt (b => b)} is true
for both values of {\tt b}.

%%If the {\tt expression for} part is omitted, the expression
%%is assumed to be {\tt var}. Thus the set
%%\begin{blogcode}
%%{Integer x: x>0 & x<5}
%%\end{blogcode}
%%contains the elements 1, 4, 9, 16, while the set 
%%\verb|{Boolean b}| contains {\it true} and {\it false}.

%%[[list comprehension: is it well defined?]]

\subsection{Maps}\label{map-section}
A map expression, used as one term in a case expression, has the form 
\begin{blogcode}
{key1 -> value1, key2 -> value2, ...}
\end{blogcode}
For example, the following map expression could be used as the
argument to a \hyperref{categorical-section}[categorical distribution]:
\begin{blogcode}
 {true -> 0.3, false -> 0.7}
\end{blogcode}
Each key must be a literal expression, while the values may be any
expressions, as long as all value expressions are of the same type.
In particular, the keys in a map can literal arrays; for example, the
map
\begin{blogcode}
{[0, 0] -> 0, [0, 1] -> 0, [1, 0] -> 0, [1, 1] -> 1}
\end{blogcode}
describes the AND of two one-bit inputs.

In a context where a distribution is required---for example, in a
\hyperref[case-distribution-section]{case distribution
  expressions}---the value expressions may all be distribution expressions.
Distribution-valued maps with literal arrays as keys are useful for
describing conditional distributions with multiple discrete parents.

\subsection{Case expressions}\label{case-distribution-section}
In \secref{if-then-else-section}, the if-then-else expression constructs a simple two-element mixture distribution whose
index variable is {\tt Fair(c)}. More complex mixture distributions and other context-specific dependencies
can be constructed using nested-if-then-else expressions. Alternatively, one may
use a {\em case expression}, which has the form
\begin{blogcode}
case expr in map
\end{blogcode}
where {\tt expr} is an arbitrary expression and {\tt map} is a mapping from keys to distribution expressions (see \secref{map-section}).
The case expression returns the distribution from the map whose key matches the value of {\tt expr}.
For example, the following describes a mixture of three Gaussians:
\begin{blogcode}
random Integer Z ~ Categorical({0 -> 0.4, 1 -> 0.5, 2 -> 0.1});
random Real X ~ 
  case Z in {
    0 -> Gaussian(0,1), 
    1 -> Gaussian(0,9), 
    2 -> Gaussian(5,1)
  };
\end{blogcode}

In the terminology of Bayesian networks, {\tt Z} in this example is a parent of {\tt X}.
If there are multiple parents, the conditional distribution can be written using
a {\tt case} expression with a list of indices. 
%% [[will ``list'' be a recognized by the manual as a proper type? At present it's not clear]]
Consider an example due initially to Judea Pearl:
the alarm in a house goes off in response to a burglary or an earthquake,
but is somewhat unreliable. We might write the following model:
\begin{blogcode}
random Boolean Burglary(House h) ~ BooleanDistrib(0.003);
random Boolean Earthquake ~ BooleanDistrib(0.002);
random Boolean Alarm(House h) ~ 
  case [Burglary(h), Earthquake] in {
    [false, false] -> BooleanDistrib(0.01),
    [false, true]  -> BooleanDistrib(0.40),
    [true, false]  -> BooleanDistrib(0.80),
    [true, true ]  -> BooleanDistrib(0.90)
  };
\end{blogcode}


\section{Distribution expressions}\label{distribution-section}
In both random function declarations and number statements, probabilistic dependencies are specified by
{\em distribution expressions}. 

A distribution expression resembles a function application, with the name of the distribution followed by its parameter arguments in parentheses. For example, a Bernoulli distribution with parameter 0.8
returns 1 with probability 0.8, 0 otherwise:
\begin{blogcode}
Bernoulli(0.8)
\end{blogcode}
The arguments may be any expressions and may include random functions. For example,
we might use a highly concentrated Beta prior for the bias of a normal coin, i.e., the probability that the coin comes up 1 (heads) rather than 0 (tails).
\begin{blogcode}
random Real Bias(Coin c) ~ Beta(50,50);
random Integer Outcome(Coin c, Toss t) ~ Bernoulli(Bias(c));
\end{blogcode}
Currently, many standard distributions are supported by \bl. A full
list of built-in distributions and their parameter specifications
appears in \appref{builtin-distribution-appendix}. 
Distribution expressions may also use user-defined distributions
(\secref{user-defined-distribution-section}).

%% [[add material on distribution type specifications]]
%% [[maybe also allow distribution declarations, so that a
%% complex distribution expression can be defined and reused (without
%% going to Java and does
%% not have to be inlined by the user; in such a case there should be
%% no difficulty with generating the sampling and likelihood code]]

\subsection{Distributions over specific sets of interest}\label{special-distribution-section}
The {\em support} of a distribution is the set of values for which
the distribution assigns non-zero probability. For example, the
support of a Gaussian distribution is the entire real line, i.e., the
type {\tt Real}. Two classes of distributions have special
significance
in \bl:
\begin{itemize}
\item {\em Boolean distributions}: any distribution whose support is
  the set $\{${\tt true}$,${\tt false}$\}$. Such distributions are
  suitable for random functions used as conditions in if-then-else
  expressions. Among the built-in distributions, {\tt BooleanDistrib}
  has this property.
\item {\em Count distributions}: any distribution whose support is
  (a subset of) the nonnegative integers $\{0,1,2,\ldots\}$. Such distributions are
  suitable for the right-hand sides of
  \hyperref[number-section]{number statements}. Among the built-in
  distributions, {\tt Bernoulli}, {\tt Binomial},
%% [[possibly also categorical, with vector-of-probabilities argument]]
  {\tt Geometric}, {\tt NegativeBinomial}, {\tt Poisson}, and {\tt
    UniformInt} (with a nonnegative lower bound) have this property.
\end{itemize}

\subsection{Categorical distribution}\label{categorical-section}

One particular built-in distribution of interest is the
{\em categorical distribution}, which specifies probabilities for each
of a finite, discrete set of elements (all of which should be of a
single type). The mapping from elements to probabilities is described
by a \hyperref[map-section]{map expression} with elements as keys and
probabilities as values. For example, the expression
\begin{blogcode}
Categorical({true -> 0.3, false -> 0.7});
\end{blogcode}
defines a distribution with a 0.3 probability for {\tt true} and a 0.7
probability for {\tt false}.

The probability values in the map argument should sum to 1.0;
otherwise, a default \texttt{null} key will be added with a
probability value equal to the residual probability.  On the other hand, if the probabilities sum to more than 1.0, the BLOG
compiler will automatically normalize the weights.


\subsection{UniformChoice from Set} \label{uniformchoice-section}
It is possible to choose from a set using the following distribution:
\begin{blogcode}
UniformChoice({x for Item x : weight(x) > 10})
\end{blogcode}
It is uniformly choosing from a set of items with weight over 10. 

\hide{
%TODO [[agreed, it woul dbe good to have a vector giving probabilities
%for 0, 1, 2.., (OR 1, 2, 3...) which is the ``standard'' definition of categorical; the
%map version is an extension. But I cannot see array as a subtype of
%map! A better option might be to use Categorical for the standard
%distribution over integers (or perhaps Categorical0 and
%Categorical1?) and Discrete for the map-based version over any finite set]]
\texttt{Array} can be viewed as a subtype of \texttt{Map}, therefore the following statement is also allowed.
\begin{blogcode}
Distribution<type>  name = Categorical(Array<Real>);
\end{blogcode}
}










\section{Observing evidence}\label{evidence-section}
Evidence statements may be declared in two ways.  The first is form is known as value evidence, and is of form:
\begin{blogcode}
obs expression1 = expression2;
\end{blogcode}
where \texttt{expression1} should be random function application expression without free variables.  For example:
\begin{blogcode}
random Real x ~ Gaussian(1.0);
obs x = 0.5;
\end{blogcode}

The second way is known as symbol evidence, and is of form:
\begin{blogcode}
obs {x for type x : expression(x)} = { x1, x2, ...}
\end{blogcode}

For example, in the aircraft example, blips may be specified in symbol evidence as follows:
\begin{blogcode}
obs {b for Blip b} = {b1, b2, b3};
\end{blogcode}
This defines three blips with names \texttt{b1}, \texttt{b2}, and \texttt{b3}.  These names can be used as expressions in queries, which are described next.

\section{Issuing queries}\label{query-section}
To specify a query, use the form:
\begin{blogcode}
query expression;
\end{blogcode}
where \texttt{expression} is a function application expression without free variables or formulas. The result will be the posterior distribution given the observations. 

[[fix to add multiple tosses, give answer]]
\begin{blogcode}
random Boolean even ~ BooleanDistrib(0.5);
random Boolean head ~
  if even then BooleanDistrib(0.5)
  else BooleanDistrib(0.8);
obs head = true;
query even;
\end{blogcode}



\section{Extending \bl}\label{-section}
\subsection{User-defined distributions}\label{user-defined-distribution-section}
Probability distributions are implemented in Java.  Distribution classes should implement the interface \verb|blog.distrib.CondProbDistrib|. 
By default, the \bl engine will look up distribution classes in the package \verb|blog.distrib|. In addition, it will look up distribution classes under the default empty package. 

{\bf Note}: using a distribution class to implement a deterministic operation is supported but not recommended. 

Below is one example of a uniform distribution on Integers.
\begin{minted}{java}
package blog.distrib;

import blog.common.Util;

public class UniformInt implements CondProbDistrib {

  /**
   * set parameters for UniformInt
   * distribution
   * 
   * @param params
   *          An array of [Integer, Integer]
   *          <ul>
   *          <li>params[0]: <code>lower</code> (Integer)</li>
   *          <li>params[1]: <code>upper</code> (Integer)</li>
   *          </ul>
   * 
   * @see blog.distrib.CondProbDistrib#setParams(java.util.List)
   */
  @Override
  public void setParams(Object[] params) {
    if (params.length != 2) {
      throw new IllegalArgumentException("expected two parameters");
    }
    setParams((Integer) params[0], (Integer) params[1]);
  }

  /**
   * For a non-null value of method parameter lower, sets the
   * distribution parameter <code>lower</code> to method parameter lower.
   * Similarly for <code>upper</code>. Then checks to see if assignment of
   * parameters is legal. In other words, an assignment of parameters is legal
   * if <code>lower <= upper</code>.
   * 
   * @param lower
   *          parameter <code>lower</code>
   * @param upper
   *          parameter <code>upper</code>
   */
  public void setParams(Integer lower, Integer upper) {
    if (lower != null) {
      this.lower = lower;
      this.hasLower = true;
    }
    if (upper != null) {
      this.upper = upper;
      this.hasUpper = true;
    }
    if (this.hasLower && this.hasUpper) {
      if (this.lower > this.upper) {
        throw new IllegalArgumentException(
            "UniformInt distribution requires that lower <= upper");
      }
      this.prob = 1.0 / (this.upper - this.lower + 1);
      this.logProb = Math.log(this.prob);
    }
  }

  private void checkHasParams() {
    if (!this.hasLower) {
      throw new IllegalArgumentException("parameter lower not provided");
    }
    if (!this.hasUpper) {
      throw new IllegalArgumentException("parameter upper not provided");
    }
  }

  /*
   * (non-Javadoc)
   * 
   * @see blog.distrib.CondProbDistrib#getProb(java.lang.Object)
   */
  @Override
  public double getProb(Object value) {
    return getProb(((Integer) value).intValue());
  }

  /**
   * Returns the probability of the UniformInt distribution having outcome
   * <code>value</code>.
   */
  public double getProb(int value) {
    checkHasParams();
    return (value >= lower) && (value <= upper) ? prob : 0;
  }

  /*
   * (non-Javadoc)
   * 
   * @see blog.distrib.CondProbDistrib#getLogProb(java.lang.Object)
   */
  @Override
  public double getLogProb(Object value) {
    return getLogProb(((Integer) value).intValue());
  }

  /**
   * Returns the log probability of the UniformInt distribution having outcome
   * <code>value</code>.
   */
  public double getLogProb(int value) {
    checkHasParams();
    return ((value >= lower) && (value <= upper)) ? logProb
        : Double.NEGATIVE_INFINITY;
  }

  /*
   * (non-Javadoc)
   * 
   * @see blog.distrib.CondProbDistrib#sampleVal()
   */
  @Override
  public Object sampleVal() {
    return sample_value();
  }

  public int sample_value() {
    checkHasParams();
    return lower + Util.randInt(upper - lower + 1);
  }

  @Override
  public String toString() {
    return getClass().getName();
  }

  /** Parameter <code>lower</code>. */
  private int lower;
  /** Flag indicating whether <code>lower</code> has been set. */
  private boolean hasLower;
  /** Parameter <code>upper</code>. */
  private int upper;
  /** Flag indicating whether <code>upper</code> has been set. */
  private boolean hasUpper;
  /**
   * The probability of an outcome between <code>lower</code> and
   * <code>upper</code> inclusive.
   */
  private double prob;
  /**
   * The log probability of an outcome between <code>lower</code> and
   * <code>upper</code> inclusive.
   */
  private double logProb;
}
\end{minted}


\section{Comprehensive examples}\label{example-section}

\subsection{Burglary}
The following example was due initially to Judea Pearl:
the alarm in a house goes off in response to a burglary or an earthquake,
but is somewhat unreliable. We might write the following model:
\begin{blogcode}
type House;

distinct House Maryhouse, Johnhouse, Cathyhouse, Rogerhouse;

random Boolean Burglary(House h) ~ BooleanDistrib(0.003);
random Boolean Earthquake ~ BooleanDistrib(0.002);
random Boolean Alarm(House h) ~ 
  case [Burglary(h), Earthquake] in {
    [false, false] -> BooleanDistrib(0.01),
    [false, true]  -> BooleanDistrib(0.40),
    [true, false]  -> BooleanDistrib(0.80),
    [true, true ]  -> BooleanDistrib(0.90)
  };

obs Alarm(Maryhouse) = true;
obs Alarm(Johnhouse) = true;
obs Alarm(Cathyhouse) = true;
obs Alarm(Rogerhouse) = false;

query Earthquake;
\end{blogcode}

\bl inference engine will produce the following likelihood of earthquake.
\begin{verbatim}
Number of samples: 10000
Distribution of values for Earthquake
	true	0.967140181036552
	false	0.03285981896344725
\end{verbatim}


\subsection{A hidden Markov model for genetic sequences}
\begin{example}[Hidden Markov models]
The following represents a hidden Markov model for genetic sequences with four states and four output symbols. The state at each time step transitions to another with respect to a conditional distribution specified by a TabularCPD. 
Each state at each time step emits an observation with respect to another CPD. After making a few observations, we can query the states for each time step.
\end{example}

\begin{blogcode}
type State;
distinct State A, C, G, T;

type Output;
distinct Output ResultA, ResultC, ResultG, ResultT;

random State S(Timestep t) ~
  if t == @0 then 
    Categorical({A -> 0.3, C -> 0.2, G -> 0.1, T -> 0.4})
  else case S(prev(t)) in {
    A -> Categorical({A -> 0.1, C -> 0.3, G -> 0.3, T -> 0.3}),
    C -> Categorical({A -> 0.3, C -> 0.1, G -> 0.3, T -> 0.3}),
    G -> Categorical({A -> 0.3, C -> 0.3, G -> 0.1, T -> 0.3}),
    T -> Categorical({A -> 0.3, C -> 0.3, G -> 0.3, T -> 0.1})
  };

random Output O(Timestep t) ~ 
  case S(t) in {
    A -> Categorical({
      ResultA -> 0.85, ResultC -> 0.05, 
      ResultG -> 0.05, ResultT -> 0.05}),
    C -> Categorical({
      ResultA -> 0.05, ResultC -> 0.85, 
      ResultG -> 0.05, ResultT -> 0.05}),
    G -> Categorical({
      ResultA -> 0.05, ResultC -> 0.05, 
      ResultG -> 0.85, ResultT -> 0.05}),
    T -> Categorical({
      ResultA -> 0.05, ResultC -> 0.05, 
      ResultG -> 0.05, ResultT -> 0.85})
  };

/* Evidence for the Hidden Markov Model.
 */

obs O(@0) = ResultC;
obs O(@1) = ResultA;
obs O(@2) = ResultA;
obs O(@3) = ResultA;
obs O(@4) = ResultG;

/* Queries for the Hiddem Markov Model, given the evidence.  
 * Note that we can query S(5) even though our observations only 
 * went up to time 4.
 */

query S(@0);
query S(@1);
query S(@2);
query S(@3);
query S(@4);
query S(@5);
\end{blogcode}

\bl will generate the following results using the particle filtering algorithm. 
\begin{verbatim}
Distribution of values for S(@0)
	C	0.8128524436090175
	T	0.09473684210526356
	A	0.06905545112781902
	G	0.023355263157894345
Distribution of values for S(@1)
	A	0.8700181159420364
	G	0.05365942028985556
	T	0.05143115942029019
	C	0.024891304347826236
Distribution of values for S(@2)
	A	0.7075761624799592
	C	0.09974612506680965
	G	0.0965058792089793
	T	0.0961718332442546
Distribution of values for S(@3)
	A	0.7633727477477481
	C	0.08085585585585582
	G	0.07908220720720713
	T	0.07668918918918921
Distribution of values for S(@4)
	G	0.8739530096536214
	C	0.050912123793299964
	T	0.05014906303236865
	A	0.02498580352072714
Distribution of values for S(@5)
	A	0.2989778534923363
	C	0.2949673480976736
	T	0.2767248722316938
	G	0.12932992617830938
\end{verbatim}

\appendix

\phantomsection
\addcontentsline{toc}{section}{\appendixtocname}


\section{A Brief  History of BLOG}\label{history-appendix}
Bayesian Logic (BLOG) was first developed by Brian Milch in 2005. Since then, major contribution is from various members of Professor Stuart Russell's research group at University of California Berkeley. 

The initial syntax and semantics of \bl was described in 

\begin{quote}
Brian Milch, Bhaskara Marthi, Stuart Russell, David Sontag, Daniel L. Ong, and Andrey Kolobov (2005) "BLOG: Probabilistic Models with Unknown Objects". Proc. 19th International Joint Conference on Artificial Intelligence (IJCAI): 1352-1359.
\end{quote}

Dr. Rodrigo Braz introduced Timestep into BLOG. Milch and Braz released \bl 0.3 in 2008.

Dr. Lei Li has been leading the development of the language and \bl inference system since 2011. Since then, the language sees major changes, as well as the inference engine. New algorithms are introduced. However, the semantics of \bl remain the same as the original. 

\section{\bl Grammar Definition}\label{bnf-appendix}

\begin{verbatim}
blog_program ::= opt_statement_lst;

opt_statement_lst ::= /* EMPTY */ 
  | statement_lst;

statement_lst ::= statement:e statement_lst
  | statement;

statement ::= declaration_stmt 
  | evidence_stmt 
  | query_stmt ;

declaration_stmt ::= type_decl
  | fixed_func_decl
  | rand_func_decl
  | origin_func_decl 
  | number_stmt 
  | distinct_decl 
  | parameter_decl 
  | distribution_decl ;

type_decl ::= TYPE ID SEMI ;

type ::= refer_name
  | array_type ;

array_type_or_sub ::= refer_name LBRACKET ;

array_type ::= array_type_or_sub RBRACKET
  | array_type LBRACKET RBRACKET ;

opt_parenthesized_type_var_lst ::= /* EMPTY */
  | LPAREN RPAREN
  | LPAREN type_var_lst RPAREN ;

type_var_lst ::= type ID COMMA type_var_lst
  | type ID ;

fixed_func_decl ::=
    FIXED type ID opt_parenthesized_type_var_lst 
    EQ expression SEMI ;

rand_func_decl ::=
    RANDOM type ID opt_parenthesized_type_var_lst 
    dependency_statement_body SEMI ;

number_stmt ::=
    NUMSIGN refer_name opt_parenthesized_origin_var_list
    dependency_statement_body SEMI;

opt_parenthesized_origin_var_list ::= /* EMPTY */
  | LPAREN origin_var_list RPAREN ;

origin_var_list ::= ID EQ ID COMMA origin_var_list
  | ID EQ ID ;

origin_func_decl ::= 
    ORIGIN type ID LPAREN type RPAREN SEMI ;

distinct_decl ::=
    DISTINCT refer_name id_or_subid_list SEMI ;

id_or_subid_list ::= id_or_subid
  | id_or_subid COMMA id_or_subid_list ;

id_or_subid ::= ID
  | ID LBRACKET INT_LITERAL RBRACKET ;

distribution_decl ::=
    DISTRIBUTION ID EQ refer_name
    LPAREN opt_expression_list RPAREN SEMI ;

refer_name ::= ID
  | ID DOT refer_name ;

dependency_statement_body ::= EQ expression
  | distribution_expr
  | IF expression THEN dependency_statement_body elseif_list ;

elseif_list ::= /* EMPTY */
  | ELSE dependency_statement_body ;

parameter_decl ::= PARAM type ID SEMI
  | PARAM type ID COLON expression SEMI ;

expression ::= operation_expr
  | distribution_expr
  | literal
  | function_call
  | list_construct_expression
  | map_construct_expression
  | quantified_formula
  | set_expr
  | number_expr
  | refer_name ;

literal ::= STRING_LITERAL
  | CHAR_LITERAL
  | INT_LITERAL
  | DOUBLE_LITERAL
  | BOOLEAN_LITERAL
  | NULL ;

operation_expr ::= expression PLUS expression
  | expression MINUS expression
  | expression MULT expression
  | expression DIV expression
  | expression MOD expression
  | expression POWER expression
  | expression LT expression
  | expression GT expression
  | expression LEQ expression
  | expression GEQ expression
  | expression EQEQ expression
  | expression NEQ expression
  | expression AND expression
  | expression OR expression
  | expression DOUBLERIGHTARROW expression
  | expression LBRACKET expression RBRACKET
  | array_type_or_sub expression RBRACKET
  | unary_operation_expr ;

unary_operation_expr ::= MINUS expression
  | NOT expression
  | AT expression
  | LPAREN expression RPAREN ;

quantified_formula ::= 
    FORALL type ID expression
  | EXISTS type ID expression ;

function_call ::= 
    refer_name LPAREN opt_expression_list RPAREN ;

distribution_expr ::= 
    DISTRIB refer_name LPAREN opt_expression_list RPAREN;

opt_expression_list ::= /* EMPTY */
  | expression_list ;

expression_list ::= expression COMMA expression_list
  | expression ;

list_construct_expression ::= 
    LBRACKET opt_expression_list RBRACKET
  | LBRACKET semi_colon_separated_expression_list RBRACKET ;

semi_colon_separated_expression_list ::=
    expression_list SEMI semi_colon_separated_expression_list
  | expression_list SEMI expression_list ;

map_construct_expression ::= 
    LBRACE expression_pair_list RBRACE ;

expression_pair_list ::=
    expression RIGHTARROW expression COMMA expression_pair_list
  | expression RIGHTARROW expression ;
  
number_expr ::= NUMSIGN set_expr
  | NUMSIGN type ;

set_expr ::= explicit_set
  | implicit_set
  | tuple_set ;

explicit_set ::= LBRACE opt_expression_list RBRACE ;

implicit_set ::= 
    LBRACE type ID COLON expression RBRACE
  | LBRACE type ID RBRACE ;

tuple_set ::= 
    LBRACE expression_list 
    FOR type_var_lst COLON expression RBRACE
  | LBRACE expression_list FOR type_var_lst RBRACE ;

evidence_stmt ::= OBS evidence SEMI ;

evidence ::= symbol_evidence
  | value_evidence ;

value_evidence ::= expression EQ expression ;

symbol_evidence ::= implicit_set EQ explicit_set ;

query_stmt ::= QUERY query SEMI ;

query ::= expression ;
\end{verbatim}


\section{Built-in operators and functions}\label{builtin-operator-appendix}
\begin{table}[H]
\centering
\caption{Arithmetic operators on Integer and Real}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
\verb|+| & plus & \verb|x + y| , \verb|1.0 + 2|\\ 
\verb|-| & minus & \verb|x - y| , \verb|1.0 - 2|\\ 
\verb|*| & multiply & \verb|x * y| , \verb|1.0 * 2|\\
\verb|/| & divide & \verb|x / y| , \verb|1.0 / 2|\\ 
\verb|%| & modulus (only applied to Integers) & \verb|x % y|, \verb|1.0 % 2| \\
\verb|^| & power & \verb|x ^ y| , \verb|1.0 ^ 2| \\
\verb|abs| & absolute value & \verb|abs(x)|,  \verb|abs(-1.0)| \\
\verb|round| & rounding & \verb|round(x)|,  \verb|round(1.6)| \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Operators on RealMatrix
\label{tab:matrixop}
}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
\verb|+| & plus & \verb|x + y| \\ 
\verb|-| & minus & \verb|x - y| \\ 
\verb|*| & multiply & \verb|x * y| \\
\verb|inv| & inverse & \verb|inv(x)| \\
\verb|transpose| & transpose & \verb|transpose(x)| \\
\verb|det| & determinant & \verb|det(x)| \\
\verb|repmat| & repeat a matrix & \verb|repmat(x, 2, 3)| \\
\verb|diag| & create a diagonal matrix & \verb|diag(x)| \\
\verb|vstack| & stacking scalars or matrices to create a larger one & \verb|vstack(x, y, z)| \\
\verb|hstack| & horizontally stacking scalars or matrices & \verb|hstack(x, y, z)| \\
\verb|eye| & identity matrix & \verb|eye(3)| \\
\verb|zeros| & zero matrix & \verb|zeros(3, 4)| \\
\verb|ones| & a matrix with all 1 & \verb|ones(3, 4)| \\
\verb|exp| & element-wise exponential  & \verb|exp(x)| \\
\bottomrule
\end{tabular}

Note the dimensionality should match. 
\end{table}

\begin{table}[H]
\centering
\caption{Conversion between types
\label{tab:conversion}
}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
\verb|toReal| & single element matrix, a number or Boolean into Real & \verb|toReal(x)| \\
\verb|toInt| & single element matrix, a number or Boolean into Int & \verb|toInt(x)| \\
\bottomrule
\end{tabular}
\end{table}



\begin{table}[H]
\centering
\caption{Logical operators on Boolean}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
\verb|&| & and & \verb|x & y| , \verb|(x > 3) & (x < 5)| \\ 
{\tt |} & or & \verb#x | y# , \verb#(x > 5) | (x < 3)# \\ 
{\tt !} & not & \verb|! x| , \verb|! (x > 3)| \\
{\tt =>} & imply & \verb|x => y| , \verb|(x > 5) => (x > 3)| \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Quantified formula}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
{\tt forall} & $\forall$ & \verb|forall Person x height(x) > 1.0| \\ 
{\tt exists} & $\exists$ & \verb|exists Person x height(x) > 1.0|  \\ 
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Relational operators on Integer, Real and other comparable types}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
{\tt >} & greater than & \verb|a > b| ,  \verb|2 > 1.0|\\ 
{\tt >=} & greater than or equal to & \verb|a >= b| ,  \verb|2 >= 1.0| \\ 
{\tt <} & less than & \verb|a < b| ,  \verb|1.0 < 2.0| \\
{\tt <=} & less than or equal to & \verb|a <= b| ,  \verb|1.0 <= 2.0|  \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Equality operator on all types}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
{\tt ==} & equal to & \verb|a == b|   \\ 
{\tt !=} & unequal to & \verb|a != b|  \\ 
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Operators on String}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
{\tt +} & concatenate & \verb|"hello " + "world"|  \\ 
{\tt ==} & equal to & \verb|"abc" == "def"|  \\
{\tt !=} & unequal to & \verb|"abc" != "def"|\\ 
\verb|IsEmptyString()| & returns True if the string is empty & \verb|IsEmptyString(a)| \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Operators on Timestep}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
\verb|prev()| & previous Timestep & \verb|prev(@1)|  \\
\verb|-| & Timestep minus an integer & \verb|@10 - 1 == @9|  \\
\verb|+| & Timestep plus an integer & \verb|@10 + 1 == @11|  \\
\verb|%| &  Timestep mod & \verb|x % 10 == @0|  \\
\verb|*| & Timestep multiply an integer & \verb|@10 * 2 == @20|  \\
\verb|/| & Timestep divide an integer & \verb|@10 / 2 == @5|  \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Arithmetic operators on Set}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
\verb|min| & minimum of elements a set & \verb|min()|\\ 
\verb|max| & maximum of elements in a set & \verb|max()|\\
\verb|sum| & summation of elements in a set & \verb|sum()|\\ 
\bottomrule
\end{tabular}
\end{table}

\section{Built-in distributions}\label{builtin-distribution-appendix}
\input{distribution-lib.tex}



\end{document}

% Optional section
%%\subsubsection{Vectors}\label{vector-section}
%%The \bl type specifier \verb|type_name[]| denotes
%%a one-dimensional vector with elements of type {\tt type_name}.
%%For example, @@
%%To declare a constant array, use the following form:
%%\begin{blogcode}
%%fixed type[] name = List_literal;
%%\end{blogcode}
%%
%%For example, to declare an array of natural numbers:
%%\begin{blogcode}
%%fixed Integer[] c = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
%%\end{blogcode}
%%
%%An element of an array can be referenced as \verb|c[0], c[1], c[2]|, etc.


%%\optional{
%%\subsection{Size of an array}\label{-section}
%%There are two special functions to obtain the size of an array, \texttt{length(\mycdot)} and \texttt{size(\mycdot)}.
%%\texttt{length(\mycdot)} returns the length of one dimensional array, while \texttt{size(\mycdot)} returns the lengths of all dimensions
%%of a multidimensional array.  In the above example, \texttt{length(table)} equals 3, and \texttt{size(table)} equals \texttt{[2, 3]}.
%%} 

%% \optional{
%% 
%% \section{Query and inference guidance}\label{-section}
%% 
%% \section{Parameters}\label{-section}
%% A parameter is only declared but not initialized with a particular value. Its value can be learned in the inference engine. To declare a parameter
%% \begin{blogcode}
%% param type1 name(type2, ...);
%% param type1 name(type2, ...) : condition;
%% \end{blogcode} 
%% This declares a parameter that should satisfy the optional condition. \texttt{condition} is a nonrandom expression that returns a Boolean value. 
%% 
%% Note here a parameter can be a function with argument of \texttt{type2, ...}, with the restriction that \texttt{type2, ...} should only involve types with distinct statements and number statements on nonrandom expression or param.
%% \reminder{a bit ugly}. 
%% 
%% Learnable parameters can be used in complex expressions. For example:
%% \begin{blogcode}
%% param Real a;
%% random Real x ~ Gaussian(2 ^ a, 1.0);
%% random Real y ~ Gaussian(a, 1.0);
%% \end{blogcode}
%% 
%% We could specifying the range of a parameter, for example:
%% \begin{blogcode}
%% param Real a: 0 < a & a < 10;
%% param Real b: b > 1;
%% random Real x ~ Gaussian(a, b);
%% \end{blogcode}
%% 
%% Commonly used parameters are often without arguments. However, the syntax does not prevent specifying infinite parameters like:
%% \begin{blogcode}
%% param Real mu(Int);
%% \end{blogcode}
%% 
%% %\hide{
%% \subsection {Array of Parameters}
%% We could define an array of parameters using
%% \begin{blogcode}
%% param type[size] name;
%% \end{blogcode}
%% where {\tt size} should be a constant natural number.
%% 
%% \begin{blogcode}
%% param Real[10] theta;
%% \end{blogcode}
%% 
%% \subsection{Declaring number param}\label{-section}
%% \reminder{Seems this will create problem to the EM algorithm}
%% A special case of parameter would the number statement. For example,
%% \begin{blogcode}
%% type Person;
%% param NaturalNum #Person;
%% param Real TrueHeight(Person p) : TrueHeight(p) > 0;
%% random Real MeasuredHeight(Person p) ~ Gaussian(TrueHeight(p), 1.0);
%% \end{blogcode}
%% We will describe the notation for distributions in Section~\ref{sec:distribution}. For the moment, we use Gaussian as a notation for Gaussian distributions.
%% This example defines a set of parameters, and its size itself is a parameter.
%% 
%% Note that since \texttt{TrueHeight} takes \texttt{Person} as an argument, we should not allow \texttt{\#Person} to be generated from a random distribution.
%% haha
%% %}
%% 
%% \section{User defined distribution}\label{-section}
%% \reminder{TO-DO, how to define pdf and sampling function?}
%% 
%% \section{Import user libraries}\label{-section}
%% \subsection{Import blog program}\label{-section}
%% \begin{blogcode}
%% import path;
%% \end{blogcode}
%% Where \texttt{path} is a java style package description.
%% 
%% For example, to import urn-ball.blog:
%% \begin{blogcode}
%% import urn-ball;
%% \end{blogcode}
%% 
%% \subsection{Referring to external library}\label{-section}
%% \begin{blogcode}
%% extern blog.distribution.*;
%% \end{blogcode}
%% It will make all implementation of Distribution visible to blog inference engine.
%% 
%% 
%% \section{Variable size array}\label{-section}
%% The size of an array is usually a constant. However it can also be random value.
%% For example:
%% \begin{blogcode}
%% random NaturalNum n ~ Poisson(10.0) + 1;
%% random Real[n] x;
%% \end{blogcode}
%% 
%% 
%% \section{Reference to Distribution}\label{-section}
%% If a distribution is referred in a \emph{general expression}, it is regarded as a random variable and will take a sample as the value.
%% For example, 
%% \begin{blogcode}
%% random Real x = 1 + Gaussian(0, 1.0);
%% \end{blogcode}
%% It has the same semantics as
%% \begin{blogcode}
%% random Real y ~ Gaussian(0, 1.0);
%% random Real x = 1 + y;
%% \end{blogcode}
%% \texttt{\~{}} is used when the right side is a distribution, while \texttt{=} is used when the right side is a general expression. 
%% \reminder{Shaunak suggests using \texttt{=} primarily, and \texttt{\~{}} only in certain cases that are not clear from context.}
%% }
%% 
 
