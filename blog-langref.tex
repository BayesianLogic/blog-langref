\documentclass[12pt]{article}
\usepackage{mathptmx}
\usepackage{courier} % use courier for typewriter font
%\renewcommand*\ttdefault{cmvtt} % use computer modern as typewriter
\usepackage[T1]{fontenc}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage[algoruled,linesnumbered]{algorithm2e}
\usepackage{amsmath,amsfonts,amsthm,amssymb}
%\usepackage{wasysym}
\usepackage{color} % add more color
\usepackage{longtable}
\usepackage{url}
%\usepackage[square,comma]{natbib}
%\renewcommand{\cite}{\citep} % use the natbib style of citation
\usepackage[tight]{subfigure}
\usepackage{mdwlist}
%\usepackage[letterpaper,twoside,vscale=.8,hscale=.75,nomarginpar,hmarginratio=1:1]{geometry}
\usepackage[parfill]{parskip}
\usepackage{rotating}
\usepackage[hang, small, bf, margin=20pt, tableposition=top]{caption}
\setlength{\belowcaptionskip}{5pt}
%\usepackage{mathpazo}
\usepackage[colorlinks,pagebackref]{hyperref}
\renewcommand*{\theHsection}{\thesection} % Correct a problem with hyperref
\usepackage[figure,table]{hypcap} 
\hypersetup{citecolor={orange},linkcolor={orange}}
\usepackage{wrapfig}
\usepackage{array} % for the use with tabular
\usepackage{xspace}
\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage[titletoc]{appendix}
%\usepackage[page,header]{appendix}
%\usepackage{titletoc}
\usepackage{float}
\usepackage{minted}

%\usemintedstyle{colorful}


\input{dfn.tex}


\renewcommand{\optional}[1]{} %uncomment for published version
\mkclean

\newcommand{\blogversion}{0.9\xspace}

\title{The \bl Language Reference  \\
{\large (\bl version \blogversion)}
}
\author{Lei Li\\
              Computer Science Division\\
              University of California Berkeley\\
               \email{leili@cs.berkeley.edu}\\
\and
               Stuart Russell\\
              Computer Science Division\\
              University of California Berkeley\\
               \email{russell@cs.berkeley.edu}\\
}
\date{\today}

%\Year{2011}

\begin{document}
\maketitle


\begin{abstract}
This document provides a reference for the syntax and semantics of \bl, a probabilistic programming language
that represents one possible form of unification for probability and first-order logic.
A \bl program consists of a set of assertions that jointly determine a probability distribution
over the space of first-order possible worlds (structures) definable using the vocabulary of
the program. In addition to allowing quantification over logical variables denoting objects and relational uncertainty,
\bl has {\em open-universe} semantics, meaning that it can represent uncertainty about the existence and
identity of objects. Hence, it is suitable for applications in which the existence of objects and events must be inferred from raw data.
The syntax as described in this document corresponds to \bl version \blogversion. This version implements many
improvements in syntax, usability, and efficiency.
\end{abstract}

\clearpage

\tableofcontents

\clearpage

\section{Introduction: Open-universe probability models and \bl}\label{intro-section}

The initial syntax and semantics of \bl was described in \cite{milch2004blog},
and in \cite{milch2005blog}.
The authors of these two papers contributed to the first implementation of the \bl language and inference algorithms.
Full details of the formal semantics are given in the Brian Milch's PhD thesis \cite{milch2006probabilistic}.

This document is primarily concerned with the detailed syntax of \bl, which has changed considerably from the initial version;
it is helpful, nonetheless, to understand the key semantic ideas, which are based on first-order logic and have remained unchanged.
A \bl \hyperref[program-section]{program} defines a probability distribution over a space of {\em possible worlds}.
It does so by means of a set of \hyperref[type-declaration-section]{type declarations},
\hyperref[number-section]{number statements}, and \hyperref[dependency-section]{dependency statements}.
These statements describe the objects that may exist in each world and introduce function symbols\footnote{Function symbols include as special cases predicate symbols (Boolean-valued functions) and constant symbols (zero-ary functions).} that carry information about the objects. \bl also supplies several \hyperref[builtin-type-section]{built-in types}
and \hyperref[builtin-operator-appendix]{built-in functions} that operate on those types.
The possible worlds are constructed from the function symbols and the objects,
and the probability of each world can be calculated from the information supplied by the dependency statements.

\subsection{Example: Writing a BLOG program}

A simple example serves to illustrate these concepts. Suppose that an urn contains unknown numbers of blue and green balls;
balls are drawn one at a time and then replaced after the observed color is noted. Color observation is 80\% accurate.
First, we define the types:
\begin{blogcode}
type Ball; 
type Draw; 
\end{blogcode}
We declare two types and use semicolons (\verb|;|) to terminate the \hyperref[type-declaration-section]{type declarations}. 
Then, we talk about the objects that exist for each type.
In this case, we know there are two colors and (say) eight draws; by writing
\begin{blogcode}
distinct Draw Draw[8];
\end{blogcode}
we name these objects and assert that the names refer to distinct \verb|Draw|'s.
On the other hand, the number of balls is (say) equally likely to be anywhere from 1 to 4; for this we use a number statement and \hyperref[uniformint-section]{\texttt{UniformInt} distribution}:
\begin{blogcode}
#Ball ~ UniformInt(1,4);
\end{blogcode}
Having made these assertions, we declare and write dependencies for the function symbols
that we need to describe the domain. First, the true color of a ball is 
equally likely to be blue or non-blue; for this, we use a boolean predicate 
\verb|isBlue|. It requires the built-in \hyperref[boolean-distribution-section]{\texttt{BooleanDistrib} distribution}, which takes a positive real number as the probability of being true:
\begin{blogcode}
random Boolean isBlue(Ball b) ~ BooleanDistrib(0.5);
\end{blogcode}
The ball drawn on each draw is \hyperref[uniformchoice-section]{chosen at random} from the balls in the urn:
\begin{blogcode}
random Ball ballDrawn(Draw d) ~ UniformChoice({b for Ball b});
\end{blogcode}
\verb|{b for Ball b}| is the \hyperref[set-section]{Set comprehension expression}. 
Finally, we say that the observed color is the same as the true color
with 80\% probability, i.e. the chance of observing blue balls being 
80\% if the true color of the ball is blue.
Here we use the \verb|if-then-else| expression:
\begin{blogcode}
random Boolean obsBlue(Draw d) ~
  if isBlue(BallDrawn(d)) then 
    BooleanDistrib(0.8)
  else
    BooleanDistrib(0.2);
\end{blogcode}
Having written dependency statements for all the function symbols, we are done.

\subsection{Example, contd.: What does the program mean?}

As noted earlier, the BLOG program defines a probability model over worlds. 
What are the worlds in this case, and what are their probabilities?

Each world has a specific number of balls, $\#Ball\eq k$, and thus contains
balls $Ball_1,\ldots,Ball_k$ in addition to eight draws $Draw_1,\ldots,Draw_8$.
(Notice we will use italics for objects in worlds, as distinct from
typewriter font for symbols in the BLOG language.)
A particular world is fixed by setting the values of every function symbol
for every possible tuple of objects of the appropriate types. We call
the value of a function symbol applied to a particular tuple of objects
a {\em basic random variable} or BRV. For this domain, the BRVs are:
\begin{itemize}
\item $isBlue_{Ball_i}$, either $true$ or $false$, for $i\eq1,\ldots,k$;
\item $ballDrawn_{Draw_j}$, one of $Ball_1,\ldots,Ball_k$,  for $j\eq1,\ldots,8$;
\item $obs_{Draw_j}$, either $true$ or $false$,  for $j\eq1,\ldots,8$.
\end{itemize}
For each $k$, there are $2^k$ values for the $isBlue$ BRVs,
$k^8$ values for the $ballDrawn$ BRVs, and $2^8$ values for
the $obsBlue$s. The total number of worlds is thus
$\sum_{k\eq 1}^4 2^k \cdot k^8 \cdot 2^8 \eq 282,135,040$.
The probability of any particular world is just the product of the probabilities 
of the choices made in ``constructing'' the world, i.e., choosing values
for the number variables and BRVs in topological order. For example, we might choose
\begin{itemize}
\item $\#Ball\eq 1$ with probability 0.25;
\item $isBlue_{Ball_1}\eq true$ with probability 0.5;
\item $ballDrawn_{Draw_j}\eq Ball_1$ with probability 1 (the only choice!) for $j\eq1,\ldots,8$;
\item $\ldots ballDrawn_{Draw_8}\eq \ldots \eq Ball_1$ with probability 1;
\item $obsBlue_{Draw_j}\eq Blue$ with probability 0.8, for $j\eq1,\ldots,8$.
\end{itemize}
The probability of this world is $0.25 \stimes 0.5 \stimes 1^8 \stimes 0.8^8\eq 0.02097152$.

\subsection{Example, contd.: Evidence and queries}

Once a model has been defined by a \bl program, evidence can be
supplied by \hyperref[evidence-section]{evidence statements}.  
Evidence is supplied by asserting observed values for expressions.
arguments (which may themselves be complex terms). In our case, we might 
assert the following:
\begin{blogcode}
obs obsBlue(Draw[0]) = true;
obs obsBlue(Draw[1]) = false;
obs obsBlue(Draw[2]) = true;
obs obsBlue(Draw[3]) = false;
obs obsBlue(Draw[4]) = true;
obs obsBlue(Draw[5]) = false;
obs obsBlue(Draw[6]) = true;
obs obsBlue(Draw[7]) = false;
\end{blogcode}
Given
evidence, a \hyperref[query-section]{query statement} indicates a
posterior probability of interest. We can query the value of any \hyperref[expression-section]{expression}
by adding a query statement to the file. Each such statement will cause the inference engine to be invoked 
and the answers---probabilities for each possible value of the
expression---to be returned to the standard output stream. Alternative output format is available but it is out of the scope. Readers may refer to \bl user's manual~\footnote{\url{http://bayesianlogic.cs.berkeley.edu/pages/user-manual.html}}. 
\begin{blogcode}
query size({b for Ball b});
\end{blogcode}
generates the following answers:
\begin{verbatim}
Distribution of values for size({b for Ball b : true})
	1	0.07696467881871667
	2	0.2749155437572819
	3	0.3066400745347743
	4	0.34147970288922114
\end{verbatim}
\begin{blogcode}
query ballDrawn(Draw[0]) == ballDrawn(Draw[1]);
\end{blogcode}
generates answers
\begin{verbatim}
Distribution of values for (ballDrawn(Draw[0]) = ballDrawn(Draw[1]))
	false	0.7070034886998044
	true	0.29299651130018706
\end{verbatim}

\section{Syntax description conventions}\label{convention-section}
In describing the syntax of \bl, we use the following conventions:
%%[[not currently implemented exactly like this; need to fix the latex code that does coloring etc]]
\begin{itemize}
\item Keywords of the language appear in bold green text: \blog|type Ball;|
\item User-defined names (e.g., {\tt Ball}) and all literal values appear in plain black text.
\item Built-in types appear in bold red text: \blog|fixed Real x = 4.567;|
\item Built-in distributions appear in plain blue text: \blog|random Integer N ~ Poisson(12);|
\item Function names appear in blue text: \blog|random Real height(Person p) ~ Gaussian(6, 1);|
%\item Logical variables appear in bold blue italic text: \blog|random Real ReportedAge(Person x) ~ Gaussian(Age(x)-Offset,Var);|
%\item Generic placeholders, to be replaced by actual names or expressions, appear in italic magenta text: \blog|type type_name;|
\item The dot-dot-dot \verb|...| notation indicates that additional elements can be added, similar to those preceding it.
\item Optional elements appear in angle brackets: \blog|if boolean-expression then expression <else expression>;|
\end{itemize}

\section{\bl Program}\label{program-section}
A \bl program consists a sequence of statements, each ending with a semicolon(;). 
The following kinds of statements are recognized:
\begin{enumerate*}
\item \hyperref[type-declaration-section]{Type declarations}, 
\item \hyperref[distinct-section]{Distinct symbol declarations}, 
\item \hyperref[fixed-section]{Fixed function declarations},
\item \hyperref[random-function-section]{Random function declarations},
\item \hyperref[origin-section]{Origin function declarations},
\item \hyperref[number-section]{Number statements},
\item \hyperref[evidence-section]{Evidence statements}, and,
\item \hyperref[query-section]{Query statements}.
\end{enumerate*}

Type declarations, distinct symbol declarations, number statements and their associated origin function declarations serve to populate
worlds with objects. Fixed and random function declarations introduce properties of objects and relationships among objects
and define distributions over the worlds that can be constructed using these functions.

A \bl program can be written in a single file. However, it is also typical to write a large \bl program in multiple files. 
By convention, \texttt{.blog} suffix is used for \bl program, and \texttt{.dblog} for those with \verb|Timestep|. 
Within a single file, the ordering of statements does not affect their semantic interpretation. However, while a \bl program consists of multiple files, they should be organized into an order such that statements in later files only refer to symbols defined within the same file or before. Such order is called {\em loading order} of a \bl program. 

\section{Lexical tokens}
\bl tokens are case sensitive. 

\subsection{Keywords} \label{keyword-section}
Keywords in \bl have preserved semantics. Currently there are the following keywords:
\begin{blogcode}
  type    distinct    fixed    random    origin
  if      then        else     case      in
  obs     query       true     false     null
\end{blogcode}

\subsection{Operators and Punctuation}
\bl supports the following punctuations:
\begin{verbatim}
  ;   {    }    (    )    [    ]
  :   =    ~    ,    #    .
\end{verbatim}
Note \verb|.| is different from \verb|.| in real numbers. 
It is only used in referring the underlying class name for a distribution. 
These punctuations are used to separating expressions or statements. 
\verb|{ }| and \verb|( )| always appear in pairs. 

\bl supports the following operators,
\begin{blogcode}
  +    -    *    /    ^    %
  >    <    >=   <=   ==   !=
  !    &    |    ->   =>
\end{blogcode}
The semantic interpretation of these operators are described in \secref{builtin-operator-appendix}.


\subsection{Identifiers}\label{identifier-section}
An identifier starts with either 26 alphabetical characters (\verb|a| to \verb|z|, \verb|A| to \verb|Z|) or underscore (\verb|_|). Then followed by any number of the 26 alphabetical characters, underscores, or digits. 
An identifier should not collide with keywords. 
Identifiers are used to refer type names, functions, distribution, distinct symbols, and logical variables. 
For example, \verb|x|, \verb|_abc1def|, and \verb|abs| are all valid identifiers. 
The first two can be used as type names, distinct symbol names, or logical variables. 
The last one, \verb|abs| refers to the library function \verb|abs()| which returns absolute value of the input argument.

\subsection{Literals}
\label{sec:literals}
\paragraph{Boolean literal}

There are two \verb|Boolean| literals: \verb|true| and \verb|false|. 

\paragraph{Integer literals}
\verb|Integer| literals are defined for all integers, ranging from $-2^{31}$ to $2^{31}-1$, e.g. \verb|-123|, \verb|0|,
\verb|7|, \verb|50000|.

\paragraph{Real literals}
\verb|Real| literals are defined for real numbers. Each real number is a
double-precision 64-bit IEEE 754 floating point. The maximal positive
\verb|Real| value is $1.7976931348623157 \times 10^{308}$, while the minimal
positive \verb|Real| value is $4.9406564584124654 \times 10^{-324}$. 
In real literals, a zero on either side of the decimal point can be omitted: \verb|123.|, \verb|123.45|, \verb|0.123|,
\verb|.123|, \verb|-45.6|. Scientific notation is also supported:
\verb|123.45e-2|, \verb|123.45E-2|, \verb|123.45e1|, \verb|123.45e+1|.


\paragraph{Character and String literals}
Character literals are delimited by single quotes: \verb|'s'|, \verb|'\n'|.
String literals are delimited by double quotes: \verb|"hello\n\nworld"|.

\paragraph{Timestep literals}
\verb|Timestep|'s correspond to nonnegative integers, but are a distinguished type
to allow for inference algorithms that are specialized for temporal models. 
\verb|Timestep| literals are distinguished by an \verb|@| prefix. They are defined for all non-negative timesteps: \verb|@0|, \verb|@1|, \verb|@654|, etc.

\paragraph{Null}
\verb|null| is a special literal that can be assigned to any \hyperref[type-declaration-section]{user declared type}. 

\subsection{Whitespace and Comments}
Tokens may be separated by whitespace characters: \textvisiblespace, tab-character, and new-line. 

Comments are in the following two forms:
\begin{itemize}
\item A single-line comment is a sequence of characters starts with \verb|//| and extends to the end of the line, or
\item A multi-line comment is a sequence of characters between \verb|/*| and \verb|*/|. Note any character after the first \verb|/*| and before the first \verb|*/| is interpreted as comment. Therefore \verb|/* /* */| is a valid comment, while \verb|/* /* */ */| is not because it has extra \verb|*/|, which \bl does not know how to interpret.
\end{itemize}

\section{Declaring types}\label{type-declaration-section}
\bl is a strongly typed language. At present the type system is extremely simple: there is no type hierarchy
and each object has exactly one type. Types must be specified for the arguments and value of every function symbol.
The types can be \hyperref[builtin-type-section]{built-in-types} or \hyperref[user-type-section]{user-defined types} from a type declaration statement.



\subsection{Built-in types}\label{builtin-type-section}
\bl has the following built-in types:
\begin{itemize}
\item \verb|Boolean|
\item \verb|Integer|
\item \verb|Real|
\item \verb|Character|
\item \verb|String|
\item \verb|Timestep|
\item \verb|RealMatrix|
\end{itemize}

\secref{sec:literals} describes the literals defined for each type.

\secref{matrix-section} describes how to construct a \verb|RealMatrix|.


\subsection{User-defined types}\label{user-type-section}

Additionally, a user may define his or her own types.  The syntax for declaring a type in \bl is:
\blog|type type_name;|
Here \verb|type_name| is an \hyperref[identifier-section]{identifier}. 
For example, the following line of \bl declares a Citation type:
\begin{blogcode}
type Citation;
\end{blogcode}

\subsection{Distinct symbols} \label{distinct-section}
Information about the objects that are elements of a user-defined type
is usually provided via a \hyperref[number-section]{number statement}, but there are cases
where the objects are known and individually distinguishable, perhaps through observations.
Names for such objects can be introduced as follows:
\begin{blogcode}
distinct type_name identifier1, identifier2, ...;
\end{blogcode}
For example, an information extraction system might have 5 citations to work with;
these can be introduced by
\begin{blogcode}
distinct Citation Cite0, Cite1, Cite2, Cite3, Cite4;
\end{blogcode}
This statement defines symbols naming 5 objects of type {\tt Citation}.
Technically, these are zero-ary function symbols whose value type is {\tt Citation};
they are necessarily distinct  (i.e., {\tt Cite1} $\neq$ {\tt Cite2}, etc.)
and each refers to the same object in all worlds. In this sense,
distinct symbols play the same role as built-in literals.

With a large number of objects, explicit naming of each is inconvenient.
In such cases, one can use an implicit construction to define {\em indexed symbols}:
\begin{blogcode}
distinct type_name prefix[int];
\end{blogcode}
where {\tt prefix} is an identifier and {\tt int} is a nonnegative integer.
For example, the following \bl code declares one hundred symbols for {\tt Citation}s:
\begin{blogcode}
distinct Citation Cite[100];
\end{blogcode}
Now the names \verb|Cite[0]|, \verb|Cite[1]|, etc., can be used to refer to these {\tt Citation}s. Note that the symbols are indexed starting from 0.

\subsection{Array and Matrix}\label{array-section}

Array types in \bl include one-dimensional vectors and two-dimensional
matrices. Functions with integer arguments can play many of the roles
usually played by arrays in ordinary programming languages, but arrays in
\bl are nonetheless useful to represent values of sets of variables
whose interaction is best described by linear algebra operations on
multiple values simultaneously, rather than one variable at a time.
For example, the velocity of an object in 3-D space can be modeled
as a vector-valued variable rather than three scalar variables.
In such cases, distributions will tend to have vector and matrix
parameters---e.g., the mean and covariance parameters of a
multivariate Gaussian.

Currently, only Integer matrix and Real matrix are fully
supported. Arrays of user declared type are only supported in distinct symbols and symbol reference as described in \secref{distinct-section}.
%%[[clarify: what does ``partially supported'' mean? Better to say
%%that support for other types will be added in future?]]

Arrays can be used as return type of functions, but not as arguments of functions. However, some distributions take arrays as arguments.

\subsubsection{Constructing List}\label{list-literal-section}
As we have already seen, we can use square brackets, \texttt{[]} to construct a List. Elements in a List are separated by commas (,). Lists can also be nested within other Lists. A shorthand notation is to use semicolons (;) to separated multiple Lists.
Thus, the following two Lists are equivalent:
\begin{blogcode}
[1, 2, 3; 4, 5, 6];
[[1, 2, 3], [4, 5, 6]];
\end{blogcode}

Lists are used to assign values to matrix, or to pass parameters to functions.

\subsubsection{Matrices}\label{matrix-section}
To define a RealMatrix:
\begin{blogcode}
fixed RealMatrix table = [[1, 2, 3], [4, 5, 6]];
\end{blogcode}
The following shorthand syntax is also allowed:
\begin{blogcode}
fixed RealMatrix table = [1, 2, 3; 4, 5, 6];
\end{blogcode}


Linear algebra operations on vectors and matrices are listed in
in \appref{builtin-operator-appendix}, \ref{sec:builtin-matrix-ops}.

\subsubsection{Matrix indexing}\label{matrix-index-section}
The index of matrices starts from 0. 

To access first row of the matrix:
\blog|a[0]|

To access the first column of the matrix:
\blog|transpose(a)[0]|

To access first element in the matrix:
\blog|a[0][0]|

Note that \verb|[]| is an operator that applies on a \verb|RealMatrix| and returns a \verb|RealMatrix|. The general form is \verb|expression1[expression2]|, where both \verb|expression| can be any kind of expression as long as the first is of \verb|RealMatrix| type, and the second is of \verb|Integer| type. In order to obtain scalar value of a singleton matrix, use \verb|toReal|. For example:

\begin{blogcode}
random Integer x ~ UniformInt(0, 2);
random Integer y ~ UniformInt(0, 2);
fixed RealMatrix a = [1, 2, 3; 4, 5, 6; 7, 8, 9];
fixed RealMatrix b = [1, 3, 5; 7, 9, 2; 4, 6, 8];
random Real z ~ toReal((a + b)[x][y]);
query z;
\end{blogcode}


\section{Dependency statements}\label{dependency-section}
\input{dependency-stmt.tex}


\section{Number statements}\label{number-section}
As noted in \secref{intro-section}, \bl supports open-universe semantics, i.e., different worlds may contain different numbers of objects and hence different numbers of random variables.
For a user-defined type, a number statement specifies a probability distribution over the number of objects of that type, possibly depending
on other aspects of the world. For example, intuitively the number of fleas in the world depends on the number of dogs.

The simplest form of number statement omits any direct dependency on other objects:
\begin{blogcode}
#type_name ~ count-distribution-expression;
\end{blogcode}
The {\tt count-distribution-expression} should be a distribution over
the nonnegative integers (see \secref{special-distribution-section}).
For example, the following example declares the number of \texttt{Ball}s according to a Poisson distribution:
\begin{blogcode}
#Ball ~ Poisson(10.0);
\end{blogcode}
As with random function declarations, a number statement can use a deterministic dependency:
\begin{blogcode}
#type_name ~ count-expression;
\end{blogcode}
% Unfortunately, the current accepted syntax is indeed "#Thing ~ 5",
% and not "#Thing = 5".

The {\tt count-expression} should evaluate to a nonnegative integer.

\subsection{Origin functions}\label{origin-section}
The general form for a number statement provides a link between the objects generated by the statement
and the objects on whose existence the new objects depend. For example, each flea's existence
depends on the existence of its host dog. This link is expressed by an {\em origin function}.
Origin functions are declared as follows:
\begin{blogcode}
origin type_name0 function-name(type_name1);
\end{blogcode}
An origin function has exactly one argument type and one return type.  
For example, we can declare {\t Host} as an origin function:
\begin{blogcode}
origin Dog Host(Flea);
\end{blogcode}

In the number statement, the origin functions are attached to the type 
as follows:
\begin{blogcode}
#type_name(origin-function1=var1, ...) ~ distribution-expression;
\end{blogcode}
For example, the number statement
\begin{blogcode}
#Flea(Host=d) ~ Poisson(2*Weight(d));
\end{blogcode}
says that the number of fleas whose {\tt Host} is dog {\tt d} has a Poisson distribution whose mean is twice the weight of the dog (bigger dogs have more fleas).
In the formal semantics of \bl, the objects in each possible world contain their origins.

An object may have multiple origins. For example, in a radar system an aircraft may generate a blip at each time step; the blip's origins are the aircraft and the time step.
\begin{blogcode}
origin Aircraft Source(Blip);
origin Timestep Time(Blip);
#Blip(Source=a,Time=t) ~ Bernoulli(0.8);
\end{blogcode}
This says that the number of blips generated by aircraft {\tt a} at time {\tt t} is drawn from
a \hyperref[builtin-distribution-appendix]{{\tt Bernoulli}} distribution that returns a 1 with probability 0.8 and a 0 otherwise.

There can be at most one number statement for a given type {\em with a given set of origin functions}. More than one number statement
can be provided as long as the set of origin functions for each is distinct. For example, suppose some radar blips are false alarms
that are not generated by any aircraft:
\begin{blogcode}
#Blip(Time=t) ~ Poisson(FalseAlarmRate*DeltaT);
\end{blogcode}

\section{Expressions}\label{expression-section}

An expression can include both fixed and random terms.  Expressions are of the following forms:
\begin{itemize}
\item A literal of a built-in type, e.g., {\tt Integer}, {\tt Real},
  {\tt String}, {\tt Boolean}, or {\tt Timestep}.
\item A user-defined symbol, one of the following:
\begin{itemize}
\item A symbol declared in a \hyperref[distinct-section]{distinct
  symbol declaration} (including indexed symbols),
\item A fixed constant, i.e., a zero-ary function symbol declared as fixed.
\item A random constant, i.e., a zero-ary function symbol declared as
  random (often called a random variable).
\item A logical variable within the scope of a function declaration
  with that variable as an argument or within the scope of a
  quantifier or set expression with that variable in the prefix.
\end{itemize}
\item A function application expression {\tt function-name(e1, e2,
  ...)}, where {\tt function-name} is a fixed, random, origin, or
  \hyperref[user-defined-function-section]{user defined} function
  symbol and the arguments {\tt e1}, {\tt e2,}, etc., are
  expressions of the appropriate types.
\item A reference to an array element {\tt A[e1]} or matrix element
  {\tt A[e1][e2]} where {\tt e1} and {\tt e2} are arbitrary
  expressions of type \verb|Integer|.%% [[vector or matrix element?
  %% need to fix our terminology and ontology; also need vector and
  %% matrix expressions, types for vectors and matrices]]
  References outside the array size will cause a runtime error.
\item A numerical expression such as \texttt{e1 + e2}, \texttt{e1 - e2},
  \texttt{e1 * e2}, \texttt{e1 / e2},  \texttt{+ e1},
  \texttt{- e1}, or \texttt{(e1)}, 
  where \texttt{e1} and \texttt{e2} are also expressions of
  type \texttt{Integer} or \texttt{Real};
  with the exception of {\tt /}, the type of the expression will be
  {\tt Integer} if all arguments are of type {\tt Integer}, and will
  be of type {\tt Real} otherwise. The full list of arithmetic
  operators is given in \appref{builtin-operator-appendix}.
  %%[[check type coercion for arithmetic expressions]]
  %%[[are a + b + c and d * e * f and d + e - f -g allowed?]]
  Expressions of the form {\tt det(M)}, where {\tt M} is an expression
  denoting a square matrix, and {\tt size(S)}, where {\tt S} is a set
  expression, are also numerical expressions.
  %%%[[check size(s) is implemented]]
\item A matrix expression such as \texttt{e1 + e2}, \texttt{e1 - e2},
  \texttt{e1 * e2}, \texttt{e1 / e2},  \texttt{+ e1},
  \texttt{- e1}, {\tt inv(e1)} \texttt{(e1)}, where {\tt e1} and {\tt
    e2} are [[vectors or matrices]] of the appropriate types and
  sizes. The full list of matrix
  operators is given in \appref{builtin-operator-appendix},
  \ref{sec:builtin-matrix-ops}.
\item A Boolean expression in one of the following forms:
\begin{itemize}
\item A logical expression: \texttt{e1 \& e2}, \texttt{e1 | e2}, \texttt{! e1}, \texttt{(e1)} where 
\texttt{e1} and \texttt{e2} are expressions of {\tt Boolean} type.
\item A comparative expression: \texttt{e1 > e2}, \texttt{e1 >= e2}, \texttt{e1 < e2}, \texttt{e1 <= e2}, where \texttt{e1} and \texttt{e2} are expressions of comparable types.
\item An equality expression: \texttt{e1 == e2}, \texttt{e1 != e2}, where \texttt{e1} and \texttt{e2} are any expressions;
\item A quantified formula (see \secref{quantifier-section}).
\end{itemize}
\item A set expression (see \secref{set-section}).
\item A map expression (see \secref{map-section}).
\item An if-then-else expression
     \blog|if condition then expression1 else expression2|
     where {\tt condition} is any Boolean expression and {\tt
       expression1} and {\tt expression2} are any expressions.
     The expression has the value of {\tt
       expression1} when {\tt condition} has the value {\it true}
     and {\tt
       expression2} when {\tt condition} has the value {\it false}.
\item A case expression
    \blog|case expr in map|
     where {\tt expr} is any Boolean expression and {\tt map} is a map
     expression.
\end{itemize}


\subsection{If-then-else expressions}\label{if-then-else-section}

An if-then-else expression allows one to use different expressions depending on aspects of the conditioning context.
The general form is
\begin{blogcode}
if condition then expression1 else expression2
\end{blogcode}
where \texttt{condition} is a \hyperref[builtin-operator-appendix]{Boolean expression} and \texttt{expression1} and \texttt{expression2}
are expressions. For example, suppose that a {\tt Coin} is exactly {\tt Fair} with probability 0.99, and that
a fair coin comes up heads half the time and a biased coin comes up heads roughly 80\% of the time:
\begin{blogcode}
random Boolean Fair(Coin c) ~ BooleanDistrib(0.99);
random Boolean Bias(Coin c) ~  
  if Fair(c) then Exactly(0.5) 
  else Beta(80,20);
\end{blogcode}
The \hyperref[builtin-distribution-appendix]{built-in distribution}
{\tt BooleanDistrib($p$)} assigns probability $p$ to {\tt true} and
$1-p$ to {\tt false}. It is equivalent to {\tt Categorical({true ->
    $p$, false -> $1-p$})}. Note that the {\tt Bernoulli($p$)}
distribution returns 0 or 1, which are not Boolean values. 

Note that if-then-else can be nested. 

%% [[explain defaults: If the else-part of an if-then-else expression is
%%    missing and the {\tt condition} is false,
%%   then what? - Exactly(0) for number statement, Exactly(null) otherwise??]]


\subsection{Quantified formula}\label{quantifier-section}
\bl allows quantified formulas, as in typed first-order logic. 
Each such formula constitutes a Boolean expression, i.e. its result type is \verb|Boolean|.

A universally quantified formula has the form
\begin{blogcode}
forall type_name var expression
\end{blogcode}
%%[[check: can quantifier prefixes have more than one variable?]]
where {\tt type\_name} is any type and {\tt var} is the name of a
logical variable. The {\tt expression} is any Boolean expression,
possibly containing {\tt var}. The formula has value {\it true}
in a given world iff {\tt expression} has value {\it true}
in {\em every} extended interpretation in which the value of {\tt var} 
is an object in the world of the given type. For example, the formula
\begin{blogcode}
forall Boolean b (b => b)
\end{blogcode}
is true in all worlds, because the Boolean objects in all worlds are 
just {\it true} and {\it false}, and the built-in function {\tt =>}
has value {\it true} for both {\tt (}{\it true} {\tt =>} {\it true}{\tt )}
and {\tt (}{\it false} {\tt =>} {\it false}{\tt )}.

An existentially quantified formula has the form
\begin{blogcode}
exists type_name var expression
\end{blogcode}
and has value {\it true}
in a given world iff {\tt expression} has value {\it true}
in {\em some} extended interpretation in which the value of {\tt var} 
is an object in the world of the given type. For example, the formula
\begin{blogcode}
exists Boolean b (b & b)
\end{blogcode}
is true in all worlds, because the Boolean objects in all worlds are 
just {\it true} and {\it false}, and the built-in function \verb|&| has value {\it true} for \verb|(true &  true)|.


Quantifier expressions may be nested, in which case
the {\tt expression} may contain logical variables from any of the
enclosing quantifier expressions.

Currently, \bl's inference algorithms have no mathematical
theorem-proving capability; hence, quantification over infinite types
leads to expressions that cannot be finitely evaluated.


\subsection{Set expressions}\label{set-section}
A set expression denotes a set of objects satisfying a certain
Boolean condition. All such sets exist implicitly in every world,
since every world contains objects and every Boolean expression
has a truth value for those objects. Normally it is not necessary to
construct set objects explicitly, since the same work can be done
using predicate expressions, but sets are useful in two contexts:
\begin{itemize}
\item When choosing values for functions, it is useful to refer to the
  set of candidate values, e.g., as an argument to a distribution.
\item When observing that certain distinct objects exist
and constitute all objects satisfying a certain condition,
a set expression can be used as the observation (see \secref{evidence-section}).
\end{itemize}
As with \hyperref[quantifier-section]{quantified formulas}, set
expressions have a logical variable that ranges over a given type.
The most general form is
\begin{blogcode}
{expression for type_name var: condition}
\end{blogcode}
where {\tt expression} is any expression, possibly including {\tt
  var}; \verb|type_name| is any declared or built-in type; {\tt var} is
a logical variable; and {\tt condition} is any Boolean expression,
possibly containing {\tt var}. The value of the set expression in any
world is the set of objects that are possible values of {\tt
  expression} as {\tt var} ranges over objects of the given type
that satisfy {\tt condition}. For example, the set
\begin{blogcode}
{(x * x) for Integer x: x>0 & x<5}
\end{blogcode}
contains the elements 1, 4, 9, 16.

If the {\tt : condition} part is omitted, the condition is 
assumed to be {\tt true}, i.e., the variable ranges over all values of
the given type. Thus, the set
\begin{blogcode}
{(b => b) for Boolean b}
\end{blogcode}
contains just {\it true}, since {\tt (b => b)} is true
for both values of {\tt b}.

%%If the {\tt expression for} part is omitted, the expression
%%is assumed to be {\tt var}. Thus the set
%%\begin{blogcode}
%%{Integer x: x>0 & x<5}
%%\end{blogcode}
%%contains the elements 1, 4, 9, 16, while the set 
%%\verb|{Boolean b}| contains {\it true} and {\it false}.

%%[[list comprehension: is it well defined?]]

\subsection{Maps}\label{map-section}
A map expression, used as one term in a case expression, has the form 
\begin{blogcode}
{key1 -> value1, key2 -> value2, ...}
\end{blogcode}
For example, the following map expression could be used as the
argument to a \hyperref{categorical-section}[categorical distribution]:
\begin{blogcode}
 {true -> 0.3, false -> 0.7}
\end{blogcode}
Each key must be a literal expression, while the values may be any
expressions, as long as all value expressions are of the same type.
In particular, the keys in a map can literal arrays; for example, the
map
\begin{blogcode}
{[0, 0] -> 0, [0, 1] -> 0, [1, 0] -> 0, [1, 1] -> 1}
\end{blogcode}
describes the AND of two one-bit inputs.

In a context where a distribution is required---for example, in a
\hyperref[case-distribution-section]{case distribution
  expressions}---the value expressions may all be distribution expressions.
Distribution-valued maps with literal arrays as keys are useful for
describing conditional distributions with multiple discrete parents.

\subsection{Case expressions}\label{case-distribution-section}
In \secref{if-then-else-section}, the if-then-else expression constructs a simple two-element mixture distribution whose
index variable is {\tt Fair(c)}. More complex mixture distributions and other context-specific dependencies
can be constructed using nested-if-then-else expressions. Alternatively, one may
use a {\em case expression}, which has the form
\begin{blogcode}
case expr in map
\end{blogcode}
where {\tt expr} is an arbitrary expression and {\tt map} is a mapping from keys to distribution expressions (see \secref{map-section}).
The case expression returns the distribution from the map whose key matches the value of {\tt expr}.
For example, the following describes a mixture of three Gaussians:
\begin{blogcode}
random Integer Z ~ Categorical({0 -> 0.4, 1 -> 0.5, 2 -> 0.1});
random Real X ~ 
  case Z in {
    0 -> Gaussian(0,1), 
    1 -> Gaussian(0,9), 
    2 -> Gaussian(5,1)
  };
\end{blogcode}

In the terminology of Bayesian networks, {\tt Z} in this example is a parent of {\tt X}.
If there are multiple parents, the conditional distribution can be written using
a {\tt case} expression with a list of indices. 
%% [[will ``list'' be a recognized by the manual as a proper type? At present it's not clear]]
Consider an example due initially to Judea Pearl:
the alarm in a house goes off in response to a burglary or an earthquake,
but is somewhat unreliable. We might write the following model:
\begin{blogcode}
random Boolean Burglary(House h) ~ BooleanDistrib(0.003);
random Boolean Earthquake ~ BooleanDistrib(0.002);
random Boolean Alarm(House h) ~ 
  case [Burglary(h), Earthquake] in {
    [false, false] -> BooleanDistrib(0.01),
    [false, true]  -> BooleanDistrib(0.40),
    [true, false]  -> BooleanDistrib(0.80),
    [true, true ]  -> BooleanDistrib(0.90)
  };
\end{blogcode}


\section{Distribution expressions}\label{distribution-section}
In both random function declarations and number statements, probabilistic dependencies are specified by
{\em distribution expressions}. 

A distribution expression resembles a function application, with the name of the distribution followed by its parameter arguments in parentheses. For example, a Bernoulli distribution with parameter 0.8
returns 1 with probability 0.8, 0 otherwise:
\begin{blogcode}
Bernoulli(0.8)
\end{blogcode}
The arguments may be any expressions and may include random functions. For example,
we might use a highly concentrated Beta prior for the bias of a normal coin, i.e., the probability that the coin comes up 1 (heads) rather than 0 (tails).
\begin{blogcode}
random Real Bias(Coin c) ~ Beta(50,50);
random Integer Outcome(Coin c, Toss t) ~ Bernoulli(Bias(c));
\end{blogcode}
Currently, many standard distributions are supported by \bl. A full
list of built-in distributions and their parameter specifications
appears in \appref{builtin-distribution-appendix}. 
Distribution expressions may also use user-defined distributions
(\secref{user-defined-distribution-section}).

%% [[add material on distribution type specifications]]
%% [[maybe also allow distribution declarations, so that a
%% complex distribution expression can be defined and reused (without
%% going to Java and does
%% not have to be inlined by the user; in such a case there should be
%% no difficulty with generating the sampling and likelihood code]]

\subsection{Distributions over specific sets of interest}\label{special-distribution-section}
The {\em support} of a distribution is the set of values for which
the distribution assigns non-zero probability. For example, the
support of a Gaussian distribution is the entire real line, i.e., the
type {\tt Real}. Two classes of distributions have special
significance
in \bl:
\begin{itemize}
\item {\em Boolean distributions}: any distribution whose support is
  the set $\{${\tt true}$,${\tt false}$\}$. Such distributions are
  suitable for random functions used as conditions in if-then-else
  expressions. Among the built-in distributions, {\tt BooleanDistrib}
  has this property.
\item {\em Count distributions}: any distribution whose support is
  (a subset of) the nonnegative integers $\{0,1,2,\ldots\}$. Such distributions are
  suitable for the right-hand sides of
  \hyperref[number-section]{number statements}. Among the built-in
  distributions, {\tt Bernoulli}, {\tt Binomial},
%% [[possibly also categorical, with vector-of-probabilities argument]]
  {\tt Geometric}, {\tt NegativeBinomial}, {\tt Poisson}, and {\tt
    UniformInt} (with a nonnegative lower bound) have this property.
\end{itemize}

\subsection{Categorical distribution}\label{categorical-section}

One particular built-in distribution of interest is the
{\em categorical distribution}, which specifies probabilities for each
of a finite, discrete set of elements (all of which should be of a
single type). The mapping from elements to probabilities is described
by a \hyperref[map-section]{map expression} with elements as keys and
probabilities as values. For example, the expression
\begin{blogcode}
Categorical({true -> 0.3, false -> 0.7});
\end{blogcode}
defines a distribution with a 0.3 probability for {\tt true} and a 0.7
probability for {\tt false}.

BLOG will automatically normalize the probability values in the map, so that
they sum to 1.0.


\subsection{UniformChoice from Set} \label{uniformchoice-section}
It is possible to choose from a set using the following distribution:
\begin{blogcode}
UniformChoice({x for Item x : weight(x) > 10})
\end{blogcode}
It is uniformly choosing from a set of items with weight over 10. 

\hide{
%TODO [[agreed, it woul dbe good to have a vector giving probabilities
%for 0, 1, 2.., (OR 1, 2, 3...) which is the ``standard'' definition of categorical; the
%map version is an extension. But I cannot see array as a subtype of
%map! A better option might be to use Categorical for the standard
%distribution over integers (or perhaps Categorical0 and
%Categorical1?) and Discrete for the map-based version over any finite set]]
\texttt{Array} can be viewed as a subtype of \texttt{Map}, therefore the following statement is also allowed.
\begin{blogcode}
Distribution<type>  name = Categorical(Array<Real>);
\end{blogcode}
}










\section{Observing evidence}\label{evidence-section}
Evidence statements may be declared in two ways.  The first way is known as
value evidence, and is of the form:
\begin{blogcode}
obs expression1 = expression2;
\end{blogcode}
where \texttt{expression1} should be a random function application expression
without free variables.  For example:
\begin{blogcode}
random Real x ~ Gaussian(1.0);
obs x = 0.5;
\end{blogcode}

The second way is known as symbol evidence, and is of the form:
\begin{blogcode}
obs {x for type x : expression(x)} = { x1, x2, ...}
\end{blogcode}

For example, in the aircraft example, blips may be specified in symbol evidence as follows:
\begin{blogcode}
obs {b for Blip b} = {b1, b2, b3};
\end{blogcode}
This defines three blips with names \texttt{b1}, \texttt{b2}, and \texttt{b3}.  These names can be used as expressions in queries, which are described next.

\section{Issuing queries}\label{query-section}
To specify a query, use the form:
\begin{blogcode}
query expression;
\end{blogcode}
where \texttt{expression} is a function application expression without free variables or formulas. The result will be the posterior distribution given the observations. 

\reminder{fix to add multiple tosses, give answer}
\begin{blogcode}
random Boolean even ~ BooleanDistrib(0.5);
random Boolean head ~
  if even then BooleanDistrib(0.5)
  else BooleanDistrib(0.8);
obs head = true;
query even;
\end{blogcode}



\section{Extending \bl}\label{extending-section}
\input{extending.tex}

\section{Comprehensive examples}\label{example-section}
\input{example.tex}



\clearpage
\appendix

\phantomsection
\addcontentsline{toc}{section}{\appendixtocname}


\hide{
\section{A Brief  History of BLOG}\label{history-appendix}
Bayesian Logic (BLOG) was first developed by Brian Milch in 2005. Since then, major contribution is from various members of Professor Stuart Russell's research group at University of California Berkeley. 

The initial syntax and semantics of \bl was described in 

\begin{quote}
Brian Milch, Bhaskara Marthi, Stuart Russell, David Sontag, Daniel L. Ong, and Andrey Kolobov (2005) "BLOG: Probabilistic Models with Unknown Objects". Proc. 19th International Joint Conference on Artificial Intelligence (IJCAI): 1352-1359.
\end{quote}

Dr. Rodrigo Braz introduced Timestep into BLOG. Milch and Braz released \bl 0.3 in 2008.

Dr. Lei Li has been leading the development of the language and \bl inference system since 2011. Since then, the language sees major changes, as well as the inference engine. New algorithms are introduced. However, the semantics of \bl remain the same as the original. 
}

\section{\bl Grammar Definition}\label{bnf-appendix}
\input{blog-bnf.tex}

\section{Built-in operators and functions}\label{builtin-operator-appendix}
\input{built-in-funcs.tex}

\section{Built-in distributions}\label{builtin-distribution-appendix}
\input{distribution-lib.tex}


\clearpage
\phantomsection
\addcontentsline{toc}{section}{Bibliography}
\bibliography{blog}
\bibliographystyle{alpha}


\end{document}

% Optional section
%%\subsubsection{Vectors}\label{vector-section}
%%The \bl type specifier \verb|type_name[]| denotes
%%a one-dimensional vector with elements of type {\tt type_name}.
%%For example, @@
%%To declare a constant array, use the following form:
%%\begin{blogcode}
%%fixed type[] name = List_literal;
%%\end{blogcode}
%%
%%For example, to declare an array of natural numbers:
%%\begin{blogcode}
%%fixed Integer[] c = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
%%\end{blogcode}
%%
%%An element of an array can be referenced as \verb|c[0], c[1], c[2]|, etc.


%%\optional{
%%\subsection{Size of an array}\label{-section}
%%There are two special functions to obtain the size of an array, \texttt{length(\mycdot)} and \texttt{size(\mycdot)}.
%%\texttt{length(\mycdot)} returns the length of one dimensional array, while \texttt{size(\mycdot)} returns the lengths of all dimensions
%%of a multidimensional array.  In the above example, \texttt{length(table)} equals 3, and \texttt{size(table)} equals \texttt{[2, 3]}.
%%} 

%% \optional{
%% 
%% \section{Query and inference guidance}\label{-section}
%% 
%% \section{Parameters}\label{-section}
%% A parameter is only declared but not initialized with a particular value. Its value can be learned in the inference engine. To declare a parameter
%% \begin{blogcode}
%% param type1 name(type2, ...);
%% param type1 name(type2, ...) : condition;
%% \end{blogcode} 
%% This declares a parameter that should satisfy the optional condition. \texttt{condition} is a nonrandom expression that returns a Boolean value. 
%% 
%% Note here a parameter can be a function with argument of \texttt{type2, ...}, with the restriction that \texttt{type2, ...} should only involve types with distinct statements and number statements on nonrandom expression or param.
%% \reminder{a bit ugly}. 
%% 
%% Learnable parameters can be used in complex expressions. For example:
%% \begin{blogcode}
%% param Real a;
%% random Real x ~ Gaussian(2 ^ a, 1.0);
%% random Real y ~ Gaussian(a, 1.0);
%% \end{blogcode}
%% 
%% We could specifying the range of a parameter, for example:
%% \begin{blogcode}
%% param Real a: 0 < a & a < 10;
%% param Real b: b > 1;
%% random Real x ~ Gaussian(a, b);
%% \end{blogcode}
%% 
%% Commonly used parameters are often without arguments. However, the syntax does not prevent specifying infinite parameters like:
%% \begin{blogcode}
%% param Real mu(Int);
%% \end{blogcode}
%% 
%% %\hide{
%% \subsection {Array of Parameters}
%% We could define an array of parameters using
%% \begin{blogcode}
%% param type[size] name;
%% \end{blogcode}
%% where {\tt size} should be a constant natural number.
%% 
%% \begin{blogcode}
%% param Real[10] theta;
%% \end{blogcode}
%% 
%% \subsection{Declaring number param}\label{-section}
%% \reminder{Seems this will create problem to the EM algorithm}
%% A special case of parameter would the number statement. For example,
%% \begin{blogcode}
%% type Person;
%% param NaturalNum #Person;
%% param Real TrueHeight(Person p) : TrueHeight(p) > 0;
%% random Real MeasuredHeight(Person p) ~ Gaussian(TrueHeight(p), 1.0);
%% \end{blogcode}
%% We will describe the notation for distributions in Section~\ref{sec:distribution}. For the moment, we use Gaussian as a notation for Gaussian distributions.
%% This example defines a set of parameters, and its size itself is a parameter.
%% 
%% Note that since \texttt{TrueHeight} takes \texttt{Person} as an argument, we should not allow \texttt{\#Person} to be generated from a random distribution.
%% haha
%% %}
%% 
%% \section{User defined distribution}\label{-section}
%% \reminder{TO-DO, how to define pdf and sampling function?}
%% 
%% \section{Import user libraries}\label{-section}
%% \subsection{Import blog program}\label{-section}
%% \begin{blogcode}
%% import path;
%% \end{blogcode}
%% Where \texttt{path} is a java style package description.
%% 
%% For example, to import urn-ball.blog:
%% \begin{blogcode}
%% import urn-ball;
%% \end{blogcode}
%% 
%% \subsection{Referring to external library}\label{-section}
%% \begin{blogcode}
%% extern blog.distribution.*;
%% \end{blogcode}
%% It will make all implementation of Distribution visible to blog inference engine.
%% 
%% 
%% \section{Variable size array}\label{-section}
%% The size of an array is usually a constant. However it can also be random value.
%% For example:
%% \begin{blogcode}
%% random NaturalNum n ~ Poisson(10.0) + 1;
%% random Real[n] x;
%% \end{blogcode}
%% 
%% 
%% \section{Reference to Distribution}\label{-section}
%% If a distribution is referred in a \emph{general expression}, it is regarded as a random variable and will take a sample as the value.
%% For example, 
%% \begin{blogcode}
%% random Real x = 1 + Gaussian(0, 1.0);
%% \end{blogcode}
%% It has the same semantics as
%% \begin{blogcode}
%% random Real y ~ Gaussian(0, 1.0);
%% random Real x = 1 + y;
%% \end{blogcode}
%% \texttt{\~{}} is used when the right side is a distribution, while \texttt{=} is used when the right side is a general expression. 
%% \reminder{Shaunak suggests using \texttt{=} primarily, and \texttt{\~{}} only in certain cases that are not clear from context.}
%% }
%% 
 
