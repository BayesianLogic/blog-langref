\documentclass[12pt]{article}
\usepackage{mathptmx}
\usepackage{courier} % use courier for typewriter font
%\renewcommand*\ttdefault{cmvtt} % use computer modern as typewriter
\usepackage[T1]{fontenc}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage[algoruled,linesnumbered]{algorithm2e}
\usepackage{amsmath,amsfonts,amsthm,amssymb}
%\usepackage{wasysym}
\usepackage{color} % add more color
\usepackage{longtable}
\usepackage{url}
\usepackage[square,comma]{natbib}
\renewcommand{\cite}{\citep} % use the natbib style of citation
\usepackage[tight]{subfigure}
\usepackage{mdwlist}
%\usepackage[letterpaper,twoside,vscale=.8,hscale=.75,nomarginpar,hmarginratio=1:1]{geometry}
\usepackage[parfill]{parskip}
\usepackage{rotating}
\usepackage[hang, small, bf, margin=20pt, tableposition=top]{caption}
\setlength{\belowcaptionskip}{5pt}
%\usepackage{mathpazo}
\usepackage[colorlinks,pagebackref]{hyperref}
\renewcommand*{\theHsection}{\thesection} % Correct a problem with hyperref
\usepackage[figure,table]{hypcap} 
\hypersetup{citecolor={orange},linkcolor={blue}}
\usepackage{wrapfig}
\usepackage{array} % for the use with tabular
\usepackage{xspace}
\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage[titletoc]{appendix}
%\usepackage[page,header]{appendix}
%\usepackage{titletoc}
\usepackage{float}
\usepackage{minted}
%\usemintedstyle{colorful}


\input{dfn.tex}
\renewcommand{\optional}[1]{} %uncomment for published version

\newcommand{\blogversion}{0.7\xspace}

\title{The BLOG Language Reference  \\
{\large (BLOG version \blogversion)}
}
\author{Lei Li\\
              Computer Science Division\\
              University of California Berkeley\\
               \email{leili@cs.berkeley.edu}\\
\and
               Stuart Russell\\
              Computer Science Division\\
              University of California Berkeley\\
               \email{russell@cs.berkeley.edu}
               }
\date{\today}

%\Year{2011}

\begin{document}
\maketitle


\begin{abstract}
This document introduces the syntax of \bl, a probabilistic programming language, for describing random variables and their probabilistic dependencies.  
\bl defines probabilistic generative models over first-order structures. For example, all Bayesian networks can be easily described by \bl.  
\bl has the following features: 
(a) it employs open-universe semantics;
(b) it can describe relational uncertainty;
(c) it can handle identity uncertainty; and
(d) it is empowered by first-order logic.
The syntax as described in this document corresponds to \bl version \blogversion. The current version represents a significant redesign and extension to previous versions of \bl, based on the principles of usability and implementation efficiency.
\end{abstract}

\clearpage

\tableofcontents

\clearpage

\section{Basic language concepts}
A \bl program consists a list of statements.
Each statement ends with semicolon(;). 
Statements include 
\begin{enumerate*}
\item Type declarations; 
\item Distinct symbol declarations;
\item Fixed function declarations;
\item Random function declarations;
\item Origin function declarations;
\item Number statements;
\item Evidence statements, and;
\item Query statements.
\end{enumerate*}

\bl is strongly typed, therefore every variable and function should explicitly specify a type.
Each \bl program defines a set of random variables and their probabilistic dependencies. 
A toy example of defining a random variable in \bl is:

\begin{blogcode}
random Real x ~ Gaussian(0, 1);
\end{blogcode}
which states that a real-valued random variable $x$ is distributed according to the standard normal distribution. 
To specify a dependent variable $y | x \sim \dnorm{x}{1}$:
\begin{blogcode}
random Real y ~ Gaussian(x, 1);
\end{blogcode}

\section{Declaring types}
\bl is a strongly typed language. Each variable should have an associated type.  \bl has the following built-in types:
\verb|Boolean|, \verb|Integer|, \verb|Real|, \verb|String|, \verb|Timestep|,  and array (which is described later).
There are \emph{literals}\index{literal} in built-in types, e.g. \verb|1.0|, \verb|''abc''|, \verb|true|, \verb|false|.

Additionally, a user may define his or her own types.  The syntax for declaring a type in \bl is:
\blog/type typename;/

For example, the following line of \bl declares a User type:
\begin{blogcode}
type User;
\end{blogcode}


\section{Fixed functions}
A fixed function always has the same semantic interpretation, i.e. its value does not change over possible worlds. 
To declare a function with fixed interpretation for all satisfying possible worlds:
\begin{blogcode}
fixed type0 funcname(type1) = expression;
\end{blogcode}
This statement defines a function with name \texttt{funcname} with one argument, of type \texttt{type1}, and with return type \texttt{type0}. 
%The function body \texttt{e} must be a fixed/nonrandom expression, which will be introduced later. 

The function body is an \texttt{expression}, which can be
\begin{itemize*}
\item a literal of built-in types;
\item an expression using built-in operators  such as \verb|a+b|, (see later sections);
\item a function call to an external interpretation implemented in a Java class, with passing of fixed term as arguments. 
\end{itemize*}

The following example defines a function to calculate the sum of squares:
\begin{blogcode}
random Real sumsquare(Real x, Real y) = x ^ 2 + y ^ 2;
\end{blogcode}

Functions can have zero or multiple arguments as well. Functions without arguments are \emph{constants}. 

\subsection{Constants}
A {\em constant} is a zero-ary fixed function.  Constants are defined in the following form:
\begin{blogcode}
fixed typename name = expression;
\end{blogcode} 
where \texttt{expression} does not contain any free variables. 
%Where the {\tt nonrandom-expression} will be described in Section~\ref{sec:expression}.

For example, constants can be defined as type literals:
\begin{blogcode}
fixed Real a = 1.0;
fixed Boolean b = true;
\end{blogcode}

Constants may also be defined using built-in functions (note that $a$ is already defined above):
\begin{blogcode}
fixed Real c = 1.0 + a;
\end{blogcode}

Such names can be referred to anywhere that fixed zero-ary function can appear.
For example:
\begin{blogcode}
random Integer x ~ Poisson(a);
\end{blogcode}
Here $x$ follows a Poisson distribution with the parameter set to $a$.

\section{Distinct symbols}
There is a special type of functions, distinct symbols. 
Distinct symbols are fixed zero-ary functions without function bodies.  Distinct symbols may be defined as follows:
\begin{blogcode}
distinct typename name1, name2, name3, ...;
\end{blogcode}
This statement defines several symbols of type typename, \texttt{name1}, \texttt{name2}, \texttt{name3} \dots.
These symbols will have a fixed interpretation across all satisfying possible worlds. In addition, all these symbols will have \emph{different} interpretations from each other. 
We can have multiple \texttt{distinct} statements in one \bl model, and all distinct symbols for a given type will have 
distinct interpretations in possible worlds. In this sense, these symbols are equivalent to ``objects'' in model structures.
Indeed, the distinct keyword is usually used to define possible values for a user-defined type.  

In addition, we can define arrays of distinct symbols with the following statement:
\begin{blogcode}
distinct typename name[int];
\end{blogcode}
For example: the following \bl code declares one hundred Person symbols.  
\begin{blogcode}
type Person;
distinct Person P[100];
\end{blogcode}

We can use \verb|P[0]|, \verb|P[1]| to refer to these symbols later. Note that the symbols are indexed starting from 0.

\paragraph{Built-in distinct symbols: literals}
There are predefined distinct symbols for Boolean, Integer, Real, and String, including all integers, all real numbers, and text strings, e.g. 1, 3.14, ``hello''. These predefined symbols are also called {\em literals}.  Also, Timestep has its own notion of time tick: @0, @1, @2, etc. 



\section{Random functions}
Random functions may have different interpretations across possible worlds. Random functions are defined in a similar way as fixed functions, but with the \texttt{random} keyword.
To declare a random function, use the following:
\begin{blogcode}
random type0 funcname(type1 x) dependency-expression;
\end{blogcode}
This statement defines a random function with name \texttt{funcname} with one argument, of type \texttt{type1}, and with return type \texttt{type0}.  The notion of a dependency statement will be introduced later, but for now consider this to be a probability distribution.

As a simple example, we can declare the height of a Person with the following \bl model: 
\begin{blogcode}
type Person;
distinct Person Alice, Bob;
random Real height(Person p) ~ Gaussian(1.70, 0.25);
\end{blogcode}



\section{Number statements}
\bl supports open world semantics, i.e. the number of objects in possible worlds can be declared in the language itself.
Traditional graphical models are constrained to a known, fixed number of objects in all worlds, and thus do not support open world semantics. 
For a user declared type, number statements specify how many objects there are of each type, and how they are generated:
\begin{blogcode}
#typename dependency-expression;
\end{blogcode}

For example, the following example declares the number of \texttt{Person}s according to a Poisson distribution:
\begin{blogcode}
type Person;
#Person ~ Poisson(10.0);
\end{blogcode}

\subsection{Origin functions}
Origin functions specify related groups of generated objects in possible worlds.  They may be defined as follows:
\begin{blogcode}
origin type0 funcname(type1);
\end{blogcode}
An origin function has exactly one argument type and one return type.  Once specified, objects may be generated from an origin function as follows:
\begin{blogcode}
#typename(origin_function=x, ...) dependency-expression;
\end{blogcode}

Below is one example of a number statement with an origin function. It declares that the total number of aircraft follows a Poisson distribution,
that each Blip has a source, which is an Aircraft object, and that the number of Blips generated by a given Aircraft follows a Bernoulli distribution.
\begin{blogcode}
type Aircraft;
type Blip;
#Aircraft ~ Poisson(10.0); 
origin Aircraft Source(Blip);
#Blip(Source=a) ~ Bernoulli(0.5);
\end{blogcode}

\section{Dependency statement}
In both nonrandom function declarations and number statements, the main body consists of dependency statements, which specify a generative process. 
A dependency statement can be of one of the following forms: simple distribution clause, simple operator clause, or conditional clauses.

A distribution clause consists of the symbol $\sim$, representing sampling, followed by the distribution name and arguments.  Arguments must match
the types of the distribution's parameters.
\begin{blogcode}
~ Distribution(args)
\end{blogcode} 
For example, below is a dependency statement to sample values from a Poisson distribution.
\begin{blogcode}
~ Poisson(10.5)
\end{blogcode}

The operator clause is specified as
\begin{blogcode}
= expression
\end{blogcode}
where \texttt{expression} is an arithmetic or relational operation. 

Conditional clauses use logical branches of the form \texttt{if then else}, 
\begin{blogcode}
if cond then clause1
else clause2
\end{blogcode}
where \texttt{cond} is a Boolean valued expression, and \texttt{clause1} and \texttt{clause2} can be one of the three types of clauses:
simple distribution clause, operator clause, or conditional clause. 

\begin{example}[Uneven coin]
There are two coins, one evenly weighted and one skewed. However, there is no visually distinction between the two. Each time we pick a coin, we flip it
and check which face appears.
\end{example}
\begin{blogcode}
random Boolean even ~ BooleanDistrib(0.5);
random Boolean head 
  if even then ~ BooleanDistrib(0.5)
  else ~ BooleanDistrib(0.8);
\end{blogcode}

\section{Observing evidence}
Evidence statements may be declared in two ways.  The first is form is known as value evidence, and is of form:
\begin{blogcode}
obs expression1 = expression2;
\end{blogcode}
where \texttt{expression1} should be random function application expression without free variables.  For example:
\begin{blogcode}
random Real x ~ Gaussian(1.0);
obs x = 0.5;
\end{blogcode}

The second way is known as symbol evidence, and is of form:
\begin{blogcode}
obs {type type0 : expression(x)} = { x1, x2, ...}
\end{blogcode}

For example, in the aircraft example, blips may be specified in symbol evidence as follows:
\begin{blogcode}
obs {Blip b} = {b1, b2, b3};
\end{blogcode}
This defines three blips with names \texttt{b1}, \texttt{b2}, and \texttt{b3}.  These names can be used as expressions in queries, which are described next.

\section{Issuing queries}
To specify a query, use the form:
\begin{blogcode}
query expression;
\end{blogcode}
where \texttt{expression} is a function application expression without free variables or formulas. The result will be the posterior distribution given the observations. 

\begin{example}[Uneven coin (continued)]
There are two coins, one evenly weighted and one skewed. However, there is no way to visually distinguish the two. Each time we pick a coin, we flip it and check which face lands facing up. What is the probability of the coin being even after we observe a head?
\end{example}
\begin{blogcode}
random Boolean even ~ BooleanDistrib(0.5);
random Boolean head 
  if even then ~ BooleanDistrib(0.5)
  else ~ BooleanDistrib(0.8);
obs head = true;
query even;
\end{blogcode}

\section{Expressions}
\label{sec:expression}
An expression can include both nonrandom and random terms.  Expressions are of the following forms:
\begin{itemize}
\item a reference to a literal of a built-in type, e.g. Integer, Real, String, Boolean and Timestep.
\item a reference to a distinct symbol;
\item a reference to a constant symbol;
\item a proper reference to an element in {\tt Array}, with index of general expression;
\item a reference to a fixed, random or origin function of form {\tt randomfun(p1, p2, \dots)}, where arguments {\tt p1, p2, \dots} are \emph{expressions};
\item an arithmetic operation on numerical type: \texttt{e1 + e2}, \texttt{e1 - e2}, \texttt{e1 * e2}, \texttt{e1 / e2},  \texttt{- e1}, \texttt{+ e1}, \texttt{- e1}, \texttt{(e1)}, where \texttt{e1} and \texttt{e2} are also \emph{expressions} of type \texttt{Integer} or \texttt{Real};
\item a logical expression on Boolean type: \texttt{e1 \& e2}, \texttt{e1 | e2}, \texttt{! e1}, \texttt{(e1)} where 
\texttt{e1} and \texttt{e2} are also \emph{expressions} of type \texttt{Boolean};
\item a relational expression: \texttt{e1 > e2}, \texttt{e1 >= e2}, \texttt{e1 < e2}, \texttt{e1 <= e2}, where \texttt{e1} and \texttt{e2} are \emph{expressions} of comparable types, or;
\item an equality expression: \texttt{e1 == e2}, \texttt{e1 != e2}, where \texttt{e1} and \texttt{e2} are themselves \emph{expressions};
\item a quantified expression: \texttt{forall t1 e1}, \texttt{exists t2 e2}, where \texttt{t1} and {t2} are types in this \bl model, and \texttt{e1} and \texttt{e2} are themselves \emph{expressions};
\end{itemize}

\subsection{Fixed expression}
A fixed expression is an expression that does not contain any random function symbols. 
For example:
\begin{blogcode}
1.0 + 2.0 * 3.0
a - 2.0
Twice(10.0) * 5.5
\end{blogcode}
Where \texttt{Twice(\mycdot)} is declared as 
\begin{blogcode}
fixed Real Twice(Real x) = x * 2;
\end{blogcode}

\subsection{Quantified formula}
\bl allows quantified formulas, as in first-order logic. To specify a universal quantified formula, 
\begin{blogcode}
forall typename x expression
\end{blogcode}
To specify an existential quantified formula,
\begin{blogcode}
exists typename x expression
\end{blogcode}

\subsection{Set expressions}
A set expression is a special type of expression which can only be used as an argument in a function call, and as observed symbol evidence. 
\begin{blogcode}
{typename x:condition(x)}
\end{blogcode}

For example, to specify uniform choice from all balls,
\begin{blogcode}
type Ball;
#Ball ~ Poisson(10.0);
random Ball choice() ~ UniformChoice({Ball b});
\end{blogcode}

To specify symbol evidence,
\begin{blogcode}
obs {Ball b} = {B1, B2, B3};
\end{blogcode}

\section{Array type}
To declare an array type
\begin{blogcode}
type[]
\end{blogcode}

Currently, only Integer arrays and Real arrays are fully supported. Arrays of other types are partially supported. Arrays are zero-indexed. Arrays can be used as return type of functions, but not as arguments of functions. However, some distributions take arrays as arguments.

\subsection{Constant array}
To declare a constant array, use the following form:
\begin{blogcode}
fixed type[] name = List_literal;
\end{blogcode}

For example, to declare an array of natural numbers:
\begin{blogcode}
fixed Integer[] c = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
\end{blogcode}

An element of an array can be referenced as \verb|c[0], c[1], c[2]|, etc.

\subsection{Constant list literals}
As we already seen, we can use square brackets, \texttt{[]} to denote constant list literals.
Elements in a list are separated by commas (,). Lists can also be nested within other list. A shorthand notation is to use semicolons (;) to separated multiple lists within a list.
Thus, the following two lists are equivalent:
\begin{blogcode}
[1, 2, 3; 4, 5, 6];
[[1, 2, 3], [4, 5, 6]];
\end{blogcode}

Constant list literals are used to assign values to arrays, or to pass parameters to functions.

\subsection{Multi-dimensional array}
Since \texttt{Array} is a type, itself could be nested in Array declaration, thus yielding multi-dimensional array. 
\begin{blogcode}
fixed type[][] table = [...];
\end{blogcode}

For example, a two dimensional array of int will be
\begin{blogcode}
fixed Integer[][] table = [[1, 2, 3], [4, 5, 6]];
\end{blogcode}
The following syntax in short hand is also correct:
\begin{blogcode}
fixed Integer[][] table = [1, 2, 3; 4, 5, 6];
\end{blogcode}


For example, a transition matrix in Kalman  filters with Newton dynamics can be declared as:
\begin{blogcode}
fixed Real[][] A = [1, 1, .5; 0, 1, 1; 0, 0, 1];
\end{blogcode}
An element in such a dimensional array can be referred as \texttt{A[0][0]}.

\optional{
\subsection{Size of an array}
There are two special functions to obtain the size of an array, \texttt{length(\mycdot)} and \texttt{size(\mycdot)}.
\texttt{length(\mycdot)} returns the length of one dimensional array, while \texttt{size(\mycdot)} returns the lengths of all dimensions
of a multidimensional array.  In the above example, \texttt{length(table)} equals 3, and \texttt{size(table)} equals \texttt{[2, 3]}.
}

\section{Map}
Maps are specified using braces. 
\begin{blogcode}
{key1 -> value1, key2 -> value2}
\end{blogcode}

For example, 
\begin{blogcode}
 {true -> 0.3, false -> 0.7}
\end{blogcode}

A Map's key must be some constant, while its value can be evaluated as the value of a \emph{expression}, as long as the type matches.
\begin{blogcode}
{true -> x^2, false -> y/2}
\end{blogcode}

In addition, \texttt{type2} in a map can be of the \texttt{Distribution} type, which will be introduced in Section~\ref{sec:distribution}.

\subsection{Multi-dimensional map}
The type in a map can be an array, which results in a multi-dimensional map.
For example,
\begin{blogcode}
{[1, 1] -> 0.1, [1, 2] -> 0.3, [2, 1] -> 0.2, [2, 2] -> 0.4};
\end{blogcode}

This will be useful in creating TabularCPD (see later sections) with multiple parent variables.


\section{Probability Distribution Library}
\label{sec:distribution}
%The internal logic is, \texttt{Categorical} and \texttt{TabularCPD} are sub-type of \texttt{Distribution}.

\subsection{Elementary Distribution}
Currently, many distributions are supported by \bl. A full list of distributions is included in the appendix. 

For example, the Gaussian distribution can be referenced via the form:
\begin{blogcode}
Gaussian(Real, Real)
\end{blogcode}

\subsection{Categorical distribution as defined by probability mass table}

The Categorical distribution is defined as follows:
\begin{blogcode}
Categorical(Map_expression);
\end{blogcode}
The map expression defines the probability mass over possible values of the distribution.

For example:
\begin{blogcode}
Categorical({true -> 0.3, false -> 0.7});
\end{blogcode}
defines a distribution where sampling yields a 0.3 probability of drawing true, and 0.7 probability of drawing false.

The probability should sum up to 1.0; otherwise, it will by default add an entry \texttt{null} with probability
equal to the residual probability.  On the other hand, if the probabilities sum to more than 1.0, the BLOG
compiler will produce a runtime error.

\hide{
%TODO
\texttt{Array} can be viewed as a subtype of \texttt{Map}, therefore the following statement is also allowed.
\begin{blogcode}
Distribution<type>  name = Categorical(Array<Real>);
\end{blogcode}
}

\subsection{TabularCPD}
To declare and construct a tabular conditional probability distribution, use the form:
\begin{blogcode}
TabularCPD(Map_expression, expression);
\end{blogcode}
which evaluates \verb|expression| as a key and generates values from the map. Note the \verb|Map_expression| should be a map from literals or array of literals to a distribution expression. 

For example, to draw from Bernoulli distribution according to the value of $x$, 
\begin{blogcode}
TabularCPD({true -> ~ Bernoulli(0.3), 
            false -> ~ Bernoulli(0.6)}, x);
\end{blogcode}

With this comprehension, we can even declare a conditional mixture of Gaussians easily. For example:
\begin{blogcode}
random Integer z ~ Categorical({0 -> 0.4, 1 -> 0.6});
random Real x ~ TabularCPD({0 -> ~Gaussian(5, 1.0), 
                 1 -> ~Gaussian(10, 1.0)}, z);
\end{blogcode}

\subsubsection{Multiple dependent variables}
To declare that a TabularCPD is dependent on several parent variables, use a multi-dimensional map:
\begin{blogcode}
TabularCPD({[0, 0] -> ~ Gaussian(5, 1.0), 
            [0, 1] -> ~ Gaussian(10, 1.0),
            [1, 0] -> ~ Gaussian(2, 4.0),
            [1, 1] -> ~ Gaussian(20, 4.0)}, [x, y])
\end{blogcode}

\hide{
\subsubsection{Tree conditionals}
If a CPD is based on a map from key to a TabularCPD, it will be a hierarchical \emph{tree conditional}. 
The following example will essentially construct the same distribution as above.
In general there can be multiple hierarchies.
}


\section{Extending \bl}
\subsection{User defined distribution}
Probability distributions are implemented in Java.  Distribution classes should implement the interface \verb|blog.distrib.CondProbDistrib|.
Alternatively, distributions can be declared as subclass of \verb|blog.distrib.AbstractCondProbDistrib|. 
By default, the \bl engine will look up distribution classes in the package \verb|blog.distrib|. In addition, it will look up distribution classes under the default empty package. 

{\bf Note}: using a distribution class to implement a deterministic operation is supported but not recommended. 

Below is one example of a uniform distribution on Integers.

\begin{minted}{java}
import java.util.*;
import blog.*;
import blog.distrib.*;
import blog.common.Util;
import blog.model.Type;

public class UniformInt extends AbstractCondProbDistrib {
  public UniformInt(List params) {
    try {
      lower = ((Number) params.get(0)).intValue();
      upper = ((Number) params.get(1)).intValue();
      if ((lower > upper) || (params.size() > 2)) {
        throw new IllegalArgumentException();
      }
    } catch (RuntimeException e) {
      throw new IllegalArgumentException(
          "UniformInt CPD expects two integer arguments "
              + "[lower, upper] with lower <= upper.  Got: " + params);
    }
  }

  public double getProb(List args, Object value) {
    if (!args.isEmpty()) {
      throw new IllegalArgumentException(
          "UniformInt CPD does not take any arguments.");
    }
    if (!(value instanceof Integer)) {
      throw new IllegalArgumentException(
          "UniformInt CPD defines distribution over objects of class "
              + "Integer, not " + value.getClass() + ".");
    }
    int x = ((Integer) value).intValue();

    if ((x >= lower) && (x <= upper)) {
      return 1.0 / (upper - lower + 1);
    }
    return 0;
  }

  public Object sampleVal(List args, Type childType) {
    if (!args.isEmpty()) {
      throw new IllegalArgumentException(
          "UniformInt CPD does not take any arguments.");
    }

    double x = lower + Math.floor(Util.random() * (upper - lower + 1));
    return new Integer((int) x);
  }

  private int lower;
  private int upper;
}
\end{minted}


\section{A comprehensive example}
\begin{example}[Hidden Markov models]
The following represents a hidden Markov model for genetic sequences with four states and four output symbols. The state at each time step transitions to another with respect to a conditional distribution specified by a TabularCPD. 
Each state at each time step emits an observation with respect to another CPD. After making a few observations, we can query the states for each time step.
\end{example}

\begin{blogcode}
type State;
distinct State A, C, G, T;
type Output;
distinct Output ResultA, ResultC, ResultG, ResultT;
random State S(Timestep t)
  if t == @0 then 
    ~ Categorical({A -> 0.3, C -> 0.2, G -> 0.1, T -> 0.4})
  else ~ TabularCPD(
    {A -> ~ Categorical({A -> 0.1, C -> 0.3, G -> 0.3, T -> 0.3}),
     C -> ~ Categorical({A -> 0.3, C -> 0.1, G -> 0.3, T -> 0.3}),
     G -> ~ Categorical({A -> 0.3, C -> 0.3, G -> 0.1, T -> 0.3}),
     T -> ~ Categorical({A -> 0.3, C -> 0.3, G -> 0.3, T -> 0.1})},
    S(Prev(t)));

random Output O(Timestep t)
  ~ TabularCPD(
    {A -> ~ Categorical({ResultA -> 0.85, ResultC -> 0.05,
                         ResultG -> 0.05, ResultT -> 0.05}),
    C -> ~ Categorical({ResultA -> 0.05, ResultC -> 0.85, 
                        ResultG -> 0.05, ResultT -> 0.05}),
    G -> ~ Categorical({ResultA -> 0.05, ResultC -> 0.05, 
                        ResultG -> 0.85, ResultT -> 0.05}),
    T -> ~ Categorical({ResultA -> 0.05, ResultC -> 0.05, 
                        ResultG -> 0.05, ResultT -> 0.85})},
    S(t));

/* Evidence for the Hidden Markov Model.
 */
obs O(@0) = ResultC;
obs O(@1) = ResultA;
obs O(@2) = ResultA;
obs O(@3) = ResultA;
obs O(@4) = ResultG;

/* Queries for the Hidden Markov Model, given the evidence.  
 * Note that we can query S(5) even though our observations 
 * only went up to time 4.
 */
query S(@0);
query S(@1);
query S(@2);
query S(@3);
query S(@4);
query S(@5);
\end{blogcode}
%\subsection{Observability}


%\appendixpage
\appendix
%\appendixpage
%\addappheadtotoc
%\begin{appendices}
\phantomsection
\addcontentsline{toc}{section}{\appendixtocname}

%\cleardoublepage


\section{Summary of changes since version 0.3 (2008)}
\begin{itemize*}
\item Support for the Map data structure;
\item Categorical and TabularCPD distribution redefined using Maps;
\item Uniform argument representation in CPD;
\item Nested if-then-else in dependency statements;
\item Direct support of boolean operations;
\item Arithmetic operators (+, -, *, /, \^), which can be used in both fixed and random function statements;
\item Support for Arrays, references to array elements, and basic matrix operators on Real Arrays (+, -, *);
\item All internal operators are type checked;
\item Support for additional operators and built-in functions (detailed in appendix);
\item Without causing confusion, ``nonrandom'' is changed to ``fixed'', ``guaranteed'' is changed to ``distinct'';
\item Complete redesign of parser and semantic translator, aimed at parsing efficiency and modularity.
\end{itemize*}

\section{Built-in operators and functions}
\begin{table}[H]
\centering
\caption{Arithmetic operators on Integer and Real}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
\verb|+| & plus & \verb|x + y| , \verb|1.0 + 2|\\ 
\verb|-| & minus & \verb|x - y| , \verb|1.0 - 2|\\ 
\verb|*| & multiply & \verb|x * y| , \verb|1.0 * 2|\\
\verb|/| & divide & \verb|x / y| , \verb|1.0 / 2|\\ 
\verb|%| & modulus (only applied to Integers) & \verb|x % y|, \verb|1.0 % 2| \\
\verb|^| & power & \verb|x ^ y| , \verb|1.0 ^ 2| \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Logical operators on Boolean}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
\verb|&| & and & \verb|x & y| , \verb|(x > 3) & (x < 5)| \\ 
{\tt |} & or & \verb\x | y\ , \verb\(x > 5) | (x < 3)\ \\ 
{\tt !} & not & \verb|! x| , \verb|! (x > 3)| \\
{\tt =>} & imply & \verb|x => y| , \verb|(x > 5) => (x > 3)| \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Quantified formula}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
{\tt forall} & $\forall$ & \verb|forall Person x height(x) > 1.0| \\ 
{\tt exists} & $\exists$ & \verb|exists Person x height(x) > 1.0|  \\ 
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Relational operators on Integer, Real and other comparable types}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
{\tt >} & greater than & \verb|a > b| ,  \verb|2 > 1.0|\\ 
{\tt >=} & greater than or equal to & \verb|a >= b| ,  \verb|2 >= 1.0| \\ 
{\tt <} & less than & \verb|a < b| ,  \verb|1.0 < 2.0| \\
{\tt <=} & less than or equal to & \verb|a <= b| ,  \verb|1.0 <= 2.0|  \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Equality operator on all types}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
{\tt ==} & equal to & \verb|a == b|   \\ 
{\tt !=} & unequal to & \verb|a != b|  \\ 
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Operators on String}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
{\tt +} & concatenate & \verb|"hello " + "world"|  \\ 
{\tt ==} & equal to & \verb|"abc" == "def"|  \\
{\tt !=} & unequal to & \verb|"abc" != "def"|\\ 
\verb|IsEmptyString()| & returns True if the string is empty & \verb|IsEmptyString(a)| \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Operators on Timestep}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
\verb|Pred()| & previous Timestep & \verb|Pred(@1)|  \\
\bottomrule
\end{tabular}
\end{table}

\section{Built-in distributions}
\begin{itemize*}
\item BooleanDistrib(p), with probability of $p$ generating \verb|True|, and $1-p$ generating \verb|False|.
\item Bernoulli(p), with probability of $p$ generating 1, and $1-p$ generating 0.
\item Beta($\alpha$, $\beta$), generating a real number $x$ in [0,1] with probability density of $\frac{x^{\alpha - 1} (1-x)^{\beta - 1}}{B(\alpha, \beta)}$, where Beta function $B$ is the normalization constant to ensure the total probability integrates to 1.
\item Binomial
\item Categorical
\item Dirichlet
\item Exponential
\item Gamma
\item Gaussian
\item Geometric
\item MultivarGaussian
\item NegativeBinomial
\item Poisson($\lambda$), generating an integer $x$ with probability $\frac{\lambda^x}{x!}e^{-\lambda}$.
\item Size($S$), deterministically returns the number of elements in the given set $S$.
\item TabularCPD
\item UniformChoice($S$), uniformly choosing one element from the given set $S$.
\item UniformInt
\item UniformReal
\end{itemize*}

\begin{table}[H]
\centering
\caption{Distributions in \bl}
\begin{tabular}{ c c c p{2in} }
\toprule 
distribution & argument type & value  & example \\ 
 \midrule
BooleanDistrib & Real in [0,1] & Boolean & \verb|BooleanDistrib(0.8)| \\ 
Bernoulli & Real in [0,1] & binary 0/1 & \verb|Bernoulli(0.8)| \\ 
Beta & Real, Real & Real in [0,1] & \verb|Beta(1.0, 1.0)| \\ 
Binomial & Integer, Real & Integer & \verb|Binomial(10, 0.5)| \\ 
Dirichlet & Array of Real & Array of Real & \verb|Dirichlet([1, 1, 1])| \\
Exponential & Real & Real & \verb|Exponential(2.0)| \\ 
Gamma & Real, Real & Real & \verb|Gamma(3, 2.0)| \\ 
Gaussian & Real, Real & Real & \verb|Gaussian(2.0, 1.0)| \\ 
Geometric & Real in [0,1] & nonnegative Integer & \verb|Geometric(0.5)| \\ 
MultivarGaussian & Array, 2D Array & Array of Real & \verb|MultivarGaussian([0, 0],| \verb| [1, 0; 0, 1])| \\
NegativeBinomial & Integer, Real in [0,1] & Integer & \verb|NegativeBinomial(4, 0.5)| \\ 
Poisson & Real & nonnegative Integer & \verb|Poisson(6.0)| \\ 
UniformChoice & Set &  & \verb|UniformChoice({Person p})| \\
UniformInt & Integer, Integer & Integer & \verb|UniformInt(0, 10)| \\
UniformReal & Real, Real & Real & \verb|UniformReal(0, 1.0)| \\
 \bottomrule
\end{tabular} 
\end{table}


\optional{

\section{Query and inference guidance}

\section{Parameters}
A parameter is only declared but not initialized with a particular value. Its value can be learned in the inference engine. To declare a parameter
\begin{blogcode}
param type1 name(type2, ...);
param type1 name(type2, ...) : condition;
\end{blogcode} 
This declares a parameter that should satisfy the optional condition. \texttt{condition} is a nonrandom expression that returns a Boolean value. 

Note here a parameter can be a function with argument of \texttt{type2, ...}, with the restriction that \texttt{type2, ...} should only involve types with distinct statements and number statements on nonrandom expression or param.
\reminder{a bit ugly}. 

Learnable parameters can be used in complex expressions. For example:
\begin{blogcode}
param Real a;
random Real x ~ Gaussian(2 ^ a, 1.0);
random Real y ~ Gaussian(a, 1.0);
\end{blogcode}

We could specifying the range of a parameter, for example:
\begin{blogcode}
param Real a: 0 < a & a < 10;
param Real b: b > 1;
random Real x ~ Gaussian(a, b);
\end{blogcode}

Commonly used parameters are often without arguments. However, the syntax does not prevent specifying infinite parameters like:
\begin{blogcode}
param Real mu(Int);
\end{blogcode}

%\hide{
\subsection {Array of Parameters}
We could define an array of parameters using
\begin{blogcode}
param type[size] name;
\end{blogcode}
where {\tt size} should be a constant natural number.

\begin{blogcode}
param Real[10] theta;
\end{blogcode}

\subsection{Declaring number param}
\reminder{Seems this will create problem to the EM algorithm}
A special case of parameter would the number statement. For example,
\begin{blogcode}
type Person;
param NaturalNum #Person;
param Real TrueHeight(Person p) : TrueHeight(p) > 0;
random Real MeasuredHeight(Person p) ~ Gaussian(TrueHeight(p), 1.0);
\end{blogcode}
We will describe the notation for distributions in Section~\ref{sec:distribution}. For the moment, we use Gaussian as a notation for Gaussian distributions.
This example defines a set of parameters, and its size itself is a parameter.

Note that since \texttt{TrueHeight} takes \texttt{Person} as an argument, we should not allow \texttt{\#Person} to be generated from a random distribution.
haha
%}

\section{User defined distribution}
\reminder{TO-DO, how to define pdf and sampling function?}

\section{Import user libraries}
\subsection{Import blog program}
\begin{blogcode}
import path;
\end{blogcode}
Where \texttt{path} is a java style package description.

For example, to import urn-ball.blog:
\begin{blogcode}
import urn-ball;
\end{blogcode}

\subsection{Referring to external library}
\begin{blogcode}
extern blog.distribution.*;
\end{blogcode}
It will make all implementation of Distribution visible to blog inference engine.


\section{Variable size array}
The size of an array is usually a constant. However it can also be random value.
For example:
\begin{blogcode}
random NaturalNum n ~ Poisson(10.0) + 1;
random Real[n] x;
\end{blogcode}


\section{Reference to Distribution}
If a distribution is referred in a \emph{general expression}, it is regarded as a random variable and will take a sample as the value.
For example, 
\begin{blogcode}
random Real x = 1 + Gaussian(0, 1.0);
\end{blogcode}
It has the same semantics as
\begin{blogcode}
random Real y ~ Gaussian(0, 1.0);
random Real x = 1 + y;
\end{blogcode}
\texttt{\~{}} is used when the right side is a distribution, while \texttt{=} is used when the right side is a general expression. 
\reminder{Shaunak suggests using \texttt{=} primarily, and \texttt{\~{}} only in certain cases that are not clear from context.}
}

%\end{appendices}

\end{document}
