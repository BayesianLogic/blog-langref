\documentclass[12pt]{article}
\usepackage{mathptmx}
\usepackage{courier} % use courier for typewriter font
%\renewcommand*\ttdefault{cmvtt} % use computer modern as typewriter
\usepackage[T1]{fontenc}
\usepackage{fullpage}
\usepackage{graphicx}
\usepackage[algoruled,linesnumbered]{algorithm2e}
\usepackage{amsmath,amsfonts,amsthm,amssymb}
%\usepackage{wasysym}
\usepackage{color} % add more color
\usepackage{longtable}
\usepackage{url}
\usepackage[square,comma]{natbib}
\renewcommand{\cite}{\citep} % use the natbib style of citation
\usepackage[tight]{subfigure}
\usepackage{mdwlist}
%\usepackage[letterpaper,twoside,vscale=.8,hscale=.75,nomarginpar,hmarginratio=1:1]{geometry}
\usepackage[parfill]{parskip}
\usepackage{rotating}
\usepackage[hang, small, bf, margin=20pt, tableposition=top]{caption}
\setlength{\belowcaptionskip}{5pt}
%\usepackage{mathpazo}
\usepackage[colorlinks,pagebackref]{hyperref}
\renewcommand*{\theHsection}{\thesection} % Correct a problem with hyperref
\usepackage[figure,table]{hypcap} 
\hypersetup{citecolor={orange},linkcolor={blue}}
\usepackage{wrapfig}
\usepackage{array} % for the use with tabular
\usepackage{xspace}
\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage[titletoc]{appendix}
%\usepackage[page,header]{appendix}
%\usepackage{titletoc}
\usepackage{float}
\usepackage{minted}
%\usemintedstyle{colorful}


\input{dfn.tex}
\renewcommand{\optional}[1]{} %uncomment for published version

\newcommand{\blogversion}{0.8\xspace}

\title{The \bl Language Reference  \\
{\large (\bl version \blogversion)}
}
\author{Lei Li\\
              Computer Science Division\\
              University of California Berkeley\\
               \email{leili@cs.berkeley.edu}\\
\and
               Stuart Russell\\
              Computer Science Division\\
              University of California Berkeley\\
               \email{russell@cs.berkeley.edu}
               }
\date{\today}

%\Year{2011}

\begin{document}
\maketitle


\begin{abstract}
This document introduces the syntax of \bl, a probabilistic programming language, for describing random variables and their probabilistic dependencies.  
\bl defines probabilistic generative models over first-order structures. For example, all Bayesian networks can be easily described by \bl.  
\bl has the following features: 
(a) it employs open-universe semantics;
(b) it can describe relational uncertainty;
(c) it can handle identity uncertainty; and
(d) it is empowered by first-order logic.
The syntax as described in this document corresponds to \bl version \blogversion. The current version represents a significant redesign and extension to previous versions of \bl, based on the principles of usability and implementation efficiency.
\end{abstract}

\clearpage

\tableofcontents

\clearpage

\section{Basic language concepts}
A \bl program consists a list of statements.
Each statement ends with semicolon(;). 
Statements include 
\begin{enumerate*}
\item Type declarations; 
\item Distinct symbol declarations;
\item Fixed function declarations;
\item Random function declarations;
\item Origin function declarations;
\item Number statements;
\item Evidence statements, and;
\item Query statements.
\end{enumerate*}

\bl is strongly typed, therefore every variable and function should explicitly specify a type.
Each \bl program defines a set of random variables and their probabilistic dependencies. 
A toy example of defining a random variable in \bl is:

\begin{blogcode}
random Integer z ~ Bernoulli(0.5);
random Real x 
  if z == 1 then ~ Gaussian(0.5, 1.0);
  else ~ Gaussian(-0.5, 1.0);
obs x = 0.2;
query z;
\end{blogcode}
which describes an mixture of Gaussian distribution. 
The latent variable \verb|z| determines the mixture component of \verb|x|. 
The program asks the possible value of \verb|z| given the evidence of \verb|x| being 0.2.
The will output a posterior distribution of $P(z | x=0.2)$;

\section{Declaring types}
\bl is a strongly typed language. Each variable should have an associated type.  \bl has the following built-in types:
\verb|Boolean|, \verb|Integer|, \verb|Real|, \verb|String|, \verb|Timestep|,  \verb|RealMatrix|, and array (which is described later).
There are \emph{literals}\index{literal} in built-in types, e.g. \verb|1.0|, \verb|"abc"|, \verb|true|, \verb|false|.

Additionally, a user may define his or her own types.  The syntax for declaring a type in \bl is:
\blog/type typename;/

For example, the following line of \bl declares a User type:
\begin{blogcode}
type User;
\end{blogcode}


\section{Fixed functions}
A fixed function always has the same semantic interpretation, i.e. its value does not change over possible worlds. 
To declare a function with fixed interpretation for all satisfying possible worlds:
\begin{blogcode}
fixed type0 funcname(type1) = expression;
\end{blogcode}
This statement defines a function with name \texttt{funcname} with one argument, of type \texttt{type1}, and with return type \texttt{type0}. 
%The function body \texttt{e} must be a fixed/nonrandom expression, which will be introduced later. 

The function body is an \texttt{expression}, which can be
\begin{itemize*}
\item a literal of built-in types;
\item an expression using built-in operators  such as \verb|a+b|, (see later sections);
\item a function call to an external interpretation implemented in a Java class, with passing of fixed term as arguments. 
\end{itemize*}

The following example defines a function to calculate the sum of squares:
\begin{blogcode}
random Real sumsquare(Real x, Real y) = x ^ 2 + y ^ 2;
\end{blogcode}

Functions can have zero or multiple arguments as well. Functions without arguments are \emph{constants}. 

\subsection{Constants}
A {\em constant} is a zero-ary fixed function.  Constants are defined in the following form:
\begin{blogcode}
fixed typename name = expression;
\end{blogcode} 
where \texttt{expression} does not contain any free variables. 
%Where the {\tt nonrandom-expression} will be described in Section~\ref{sec:expression}.

For example, constants can be defined as type literals:
\begin{blogcode}
fixed Real a = 1.0;
fixed Boolean b = true;
\end{blogcode}

Constants may also be defined using built-in functions (note that $a$ is already defined above):
\begin{blogcode}
fixed Real c = 1.0 + a;
\end{blogcode}

Such names can be referred to anywhere that fixed zero-ary function can appear.
For example:
\begin{blogcode}
random Integer x ~ Poisson(a);
\end{blogcode}
Here $x$ follows a Poisson distribution with the parameter set to $a$.

\section{Distinct symbols}
There is a special type of functions, distinct symbols. 
Distinct symbols are fixed zero-ary functions without function bodies.  Distinct symbols may be defined as follows:
\begin{blogcode}
distinct typename name1, name2, name3, ...;
\end{blogcode}
This statement defines several symbols of type typename, \texttt{name1}, \texttt{name2}, \texttt{name3} \dots.
These symbols will have a fixed interpretation across all satisfying possible worlds. In addition, all these symbols will have \emph{different} interpretations from each other. 
We can have multiple \texttt{distinct} statements in one \bl model, and all distinct symbols for a given type will have 
distinct interpretations in possible worlds. In this sense, these symbols are equivalent to ``objects'' in model structures.
Indeed, the distinct keyword is usually used to define possible values for a user-defined type.  

In addition, we can define arrays of distinct symbols with the following statement:
\begin{blogcode}
distinct typename name[int];
\end{blogcode}
For example: the following \bl code declares one hundred Person symbols.  
\begin{blogcode}
type Person;
distinct Person P[100];
\end{blogcode}

We can use \verb|P[0]|, \verb|P[1]| to refer to these symbols later. Note that the symbols are indexed starting from 0.

\paragraph{Built-in distinct symbols: literals}
There are predefined distinct symbols for Boolean, Integer, Real, and String, including all integers, all real numbers, and text strings, e.g. 1, 3.14, ``hello''. These predefined symbols are also called {\em literals}.  Also, Timestep has its own notion of time tick: @0, @1, @2, etc. 



\section{Random functions}
Random functions may have different interpretations across possible worlds. Random functions are defined in a similar way as fixed functions, but with the \texttt{random} keyword.
To declare a random function, use the following:
\begin{blogcode}
random type0 funcname(type1 x) dependency-expression;
\end{blogcode}
This statement defines a random function with name \texttt{funcname} with one argument, of type \texttt{type1}, and with return type \texttt{type0}.  The notion of a dependency statement will be introduced later, but for now consider this to be a probability distribution.

As a simple example, we can declare the height of a Person with the following \bl model: 
\begin{blogcode}
type Person;
distinct Person Alice, Bob;
random Real height(Person p) ~ Gaussian(1.70, 0.25);
\end{blogcode}



\section{Number statements}
\bl supports open world semantics, i.e. the number of objects in possible worlds can be declared in the language itself.
Traditional graphical models are constrained to a known, fixed number of objects in all worlds, and thus do not support open world semantics. 
For a user declared type, number statements specify how many objects there are of each type, and how they are generated:
\begin{blogcode}
#typename dependency-expression;
\end{blogcode}

For example, the following example declares the number of \texttt{Person}s according to a Poisson distribution:
\begin{blogcode}
type Person;
#Person ~ Poisson(10.0);
\end{blogcode}

\subsection{Origin functions}
Origin functions specify related groups of generated objects in possible worlds.  They may be defined as follows:
\begin{blogcode}
origin type0 funcname(type1);
\end{blogcode}
An origin function has exactly one argument type and one return type.  Once specified, objects may be generated from an origin function as follows:
\begin{blogcode}
#typename(origin_function=x, ...) dependency-expression;
\end{blogcode}

Below is one example of a number statement with an origin function. It declares that the total number of aircraft follows a Poisson distribution,
that each Blip has a source, which is an Aircraft object, and that the number of Blips generated by a given Aircraft follows a Bernoulli distribution.
\begin{blogcode}
type Aircraft;
type Blip;
#Aircraft ~ Poisson(10.0); 
origin Aircraft Source(Blip);
#Blip(Source=a) ~ Bernoulli(0.5);
\end{blogcode}

\section{Dependency statement}
In both nonrandom function declarations and number statements, the main body consists of dependency statements, which specify a generative process. 
A dependency statement can be of one of the following forms: simple distribution clause, simple operator clause, or conditional clauses.

A distribution clause consists of the symbol $\sim$, representing sampling, followed by the distribution name and arguments.  Arguments must match
the types of the distribution's parameters.
\begin{blogcode}
~ Distribution(args)
\end{blogcode} 
For example, below is a dependency statement to sample values from a Poisson distribution.
\begin{blogcode}
~ Poisson(10.5)
\end{blogcode}

The operator clause is specified as
\begin{blogcode}
= expression
\end{blogcode}
where \texttt{expression} is an arithmetic or relational operation. 

Conditional clauses use logical branches of the form \texttt{if then else}, 
\begin{blogcode}
if cond then clause1
else clause2
\end{blogcode}
where \texttt{cond} is a Boolean valued expression, and \texttt{clause1} and \texttt{clause2} can be one of the three types of clauses:
simple distribution clause, operator clause, or conditional clause. 

\begin{example}[Uneven coin]
There are two coins, one evenly weighted and one skewed. However, there is no visually distinction between the two. Each time we pick a coin, we flip it
and check which face appears.
\end{example}
\begin{blogcode}
random Boolean even ~ BooleanDistrib(0.5);
random Boolean head 
  if even then ~ BooleanDistrib(0.5)
  else ~ BooleanDistrib(0.8);
\end{blogcode}

\section{Observing evidence}
Evidence statements may be declared in two ways.  The first is form is known as value evidence, and is of form:
\begin{blogcode}
obs expression1 = expression2;
\end{blogcode}
where \texttt{expression1} should be random function application expression without free variables.  For example:
\begin{blogcode}
random Real x ~ Gaussian(1.0);
obs x = 0.5;
\end{blogcode}

The second way is known as symbol evidence, and is of form:
\begin{blogcode}
obs {type type0 : expression(x)} = { x1, x2, ...}
\end{blogcode}

For example, in the aircraft example, blips may be specified in symbol evidence as follows:
\begin{blogcode}
obs {Blip b} = {b1, b2, b3};
\end{blogcode}
This defines three blips with names \texttt{b1}, \texttt{b2}, and \texttt{b3}.  These names can be used as expressions in queries, which are described next.

\section{Issuing queries}
To specify a query, use the form:
\begin{blogcode}
query expression;
\end{blogcode}
where \texttt{expression} is a function application expression without free variables or formulas. The result will be the posterior distribution given the observations. 

\begin{example}[Uneven coin (continued)]
There are two coins, one evenly weighted and one skewed. However, there is no way to visually distinguish the two. Each time we pick a coin, we flip it and check which face lands facing up. What is the probability of the coin being even after we observe a head?
\end{example}
\begin{blogcode}
random Boolean even ~ BooleanDistrib(0.5);
random Boolean head 
  if even then ~ BooleanDistrib(0.5)
  else ~ BooleanDistrib(0.8);
obs head = true;
query even;
\end{blogcode}

\section{Expressions}
\label{sec:expression}
An expression can include both nonrandom and random terms.  Expressions are of the following forms:
\begin{itemize}
\item a reference to a literal of a built-in type, e.g. Integer, Real, String, Boolean and Timestep.
\item a reference to a distinct symbol;
\item a reference to a constant symbol;
\item a proper reference to an element in {\tt Array}, with index of general expression;
\item a reference to a fixed, random or origin function of form {\tt randomfun(p1, p2, \dots)}, where arguments {\tt p1, p2, \dots} are \emph{expressions};
\item an arithmetic operation on numerical type: \texttt{e1 + e2}, \texttt{e1 - e2}, \texttt{e1 * e2}, \texttt{e1 / e2},  \texttt{- e1}, \texttt{+ e1}, \texttt{- e1}, \texttt{(e1)}, where \texttt{e1} and \texttt{e2} are also \emph{expressions} of type \texttt{Integer} or \texttt{Real};
\item a logical expression on Boolean type: \texttt{e1 \& e2}, \texttt{e1 | e2}, \texttt{! e1}, \texttt{(e1)} where 
\texttt{e1} and \texttt{e2} are also \emph{expressions} of type \texttt{Boolean};
\item a relational expression: \texttt{e1 > e2}, \texttt{e1 >= e2}, \texttt{e1 < e2}, \texttt{e1 <= e2}, where \texttt{e1} and \texttt{e2} are \emph{expressions} of comparable types, or;
\item an equality expression: \texttt{e1 == e2}, \texttt{e1 != e2}, where \texttt{e1} and \texttt{e2} are themselves \emph{expressions};
\item a quantified expression: \texttt{forall t1 e1}, \texttt{exists t2 e2}, where \texttt{t1} and {t2} are types in this \bl model, and \texttt{e1} and \texttt{e2} are themselves \emph{expressions};
\end{itemize}

\subsection{Fixed expression}
A fixed expression is an expression that does not contain any random function symbols. 
For example:
\begin{blogcode}
1.0 + 2.0 * 3.0
a - 2.0
Twice(10.0) * 5.5
\end{blogcode}
Where \texttt{Twice(\mycdot)} is declared as 
\begin{blogcode}
fixed Real Twice(Real x) = x * 2;
\end{blogcode}

\subsection{Quantified formula}
\bl allows quantified formulas, as in first-order logic. To specify a universal quantified formula, 
\begin{blogcode}
forall typename x expression
\end{blogcode}
To specify an existential quantified formula,
\begin{blogcode}
exists typename x expression
\end{blogcode}

\subsection{Set expressions}
A set expression is a special type of expression which can only be used as an argument in a function call, and as observed symbol evidence. 
\begin{blogcode}
{typename x:condition(x)}
\end{blogcode}

For example, to specify uniform choice from all balls,
\begin{blogcode}
type Ball;
#Ball ~ Poisson(10.0);
random Ball choice() ~ UniformChoice({Ball b});
\end{blogcode}

To specify symbol evidence,
\begin{blogcode}
obs {Ball b} = {B1, B2, B3};
\end{blogcode}


\subsection{TupleSet}
A \verb|TupleSet| is a set comprehension.
\begin{blogcode}
{<expression1>, <expression2> for typename1 x}
\end{blogcode}


\section{Array and Matrix}
To declare an array type
\begin{blogcode}
type[]
\end{blogcode}

Currently, only Integer arrays and Real arrays are fully supported. Arrays of other types are partially supported. Arrays are zero-indexed. Arrays can be used as return type of functions, but not as arguments of functions. However, some distributions take arrays as arguments.

\subsection{Constant array}
To declare a constant array, use the following form:
\begin{blogcode}
fixed type[] name = List_literal;
\end{blogcode}

For example, to declare an array of natural numbers:
\begin{blogcode}
fixed Integer[] c = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
\end{blogcode}

An element of an array can be referenced as \verb|c[0], c[1], c[2]|, etc.

\subsection{Constant list literals}
As we already seen, we can use square brackets, \texttt{[]} to denote constant list literals.
Elements in a list are separated by commas (,). Lists can also be nested within other list. A shorthand notation is to use semicolons (;) to separated multiple lists within a list.
Thus, the following two lists are equivalent:
\begin{blogcode}
[1, 2, 3; 4, 5, 6];
[[1, 2, 3], [4, 5, 6]];
\end{blogcode}

Constant list literals are used to assign values to arrays, or to pass parameters to functions.

\subsection{Matrix}
To define a Matrix
\begin{blogcode}
fixed RealMatrix table = [...];
\end{blogcode}

For example, a two dimensional array of int will be
\begin{blogcode}
fixed RealMatrix table = [[1, 2, 3], [4, 5, 6]];
\end{blogcode}
The following syntax in short hand is also correct:
\begin{blogcode}
fixed RealMatrix table = [1, 2, 3; 4, 5, 6];
\end{blogcode}


For example, a transition matrix in Kalman  filters with Newton dynamics can be declared as:
\begin{blogcode}
fixed RealMatrix A = [1, 1, .5; 0, 1, 1; 0, 0, 1];
\end{blogcode}
An element in such a dimensional array can be referred as \texttt{A[0][0]}.

\optional{
\subsection{Size of an array}
There are two special functions to obtain the size of an array, \texttt{length(\mycdot)} and \texttt{size(\mycdot)}.
\texttt{length(\mycdot)} returns the length of one dimensional array, while \texttt{size(\mycdot)} returns the lengths of all dimensions
of a multidimensional array.  In the above example, \texttt{length(table)} equals 3, and \texttt{size(table)} equals \texttt{[2, 3]}.
}

\subsection{Linear algebra operations}
\bl supports the following linear algebra operations.
\begin{itemize}
\item vector plus, minus, multiplcation. Both arguments should be \verb|RealMatrix|.  Result is a vector, i.e. \verb|RealMatrix|;
\begin{blogcode}
fixed RealMatrix a = [1, 2];
fixed RealMatrix b = [4, 5];
random RealMatrix x = a + b - a;
fixed RealMatrix a = [1, 2];
fixed RealMatrix b = [4, 5];
fixed RealMatrix c = [1, 2; 3, 4];
fixed RealMatrix d = [4, 5; 6, 7];
random RealMatrix w = a * 10.0 + 20.0 * b;
random RealMatrix y = c * d;
random RealMatrix z = c * 3.0 + 4.0 * d - c;
random RealMatrix u = a * c;
fixed RealMatrix e = [10; 20];
random RealMatrix v = c * e;
\end{blogcode}
\item matrix inverse. 
\begin{blogcode}
fixed RealMatrix c = [1, 2; 3, 4];
random RealMatrix s = inv(c);
\end{blogcode}
\item matrix determinant. Result is Real.
\begin{blogcode}
fixed RealMatrix c = [1, 2; 3, 4];
random Real t = det(c);
\end{blogcode}
\item transpose. 
\end{itemize}
The full list is in appendix, Table~\ref{tab:matrixop}.

\section{Map}
Maps are specified using braces. 
\begin{blogcode}
{key1 -> value1, key2 -> value2}
\end{blogcode}

For example, 
\begin{blogcode}
 {true -> 0.3, false -> 0.7}
\end{blogcode}

A Map's key must be some constant, while its value can be evaluated as the value of a \emph{expression}, as long as the type matches.
\begin{blogcode}
{true -> x^2, false -> y/2}
\end{blogcode}

In addition, \texttt{type2} in a map can be of the \texttt{Distribution} type, which will be introduced in Section~\ref{sec:distribution}.

\subsection{Multi-dimensional map}
The type in a map can be an array, which results in a multi-dimensional map.
For example,
\begin{blogcode}
{[1, 1] -> 0.1, [1, 2] -> 0.3, [2, 1] -> 0.2, [2, 2] -> 0.4};
\end{blogcode}

This will be useful in creating TabularCPD (see later sections) with multiple parent variables.


\section{Probability Distribution Library}
\label{sec:distribution}
%The internal logic is, \texttt{Categorical} and \texttt{TabularCPD} are sub-type of \texttt{Distribution}.

\subsection{Elementary Distribution}
Currently, many distributions are supported by \bl. A full list of distributions is included in the appendix. 

For example, the Gaussian distribution can be referenced via the form:
\begin{blogcode}
Gaussian(Real, Real)
\end{blogcode}

\subsection{Categorical distribution as defined by probability mass table}

The Categorical distribution is defined as follows:
\begin{blogcode}
Categorical(Map_expression);
\end{blogcode}
The map expression defines the probability mass over possible values of the distribution.

For example:
\begin{blogcode}
Categorical({true -> 0.3, false -> 0.7});
\end{blogcode}
defines a distribution where sampling yields a 0.3 probability of drawing true, and 0.7 probability of drawing false.

The probability should sum up to 1.0; otherwise, it will by default add an entry \texttt{null} with probability
equal to the residual probability.  On the other hand, if the probabilities sum to more than 1.0, the BLOG
compiler will produce a runtime error.

\hide{
%TODO
\texttt{Array} can be viewed as a subtype of \texttt{Map}, therefore the following statement is also allowed.
\begin{blogcode}
Distribution<type>  name = Categorical(Array<Real>);
\end{blogcode}
}

\subsection{TabularCPD}
To declare and construct a tabular conditional probability distribution, use the form:
\begin{blogcode}
TabularCPD(Map_expression, expression);
\end{blogcode}
which evaluates \verb|expression| as a key and generates values from the map. Note the \verb|Map_expression| should be a map from literals or array of literals to a distribution expression. 

For example, to draw from Bernoulli distribution according to the value of $x$, 
\begin{blogcode}
TabularCPD({true -> ~ Bernoulli(0.3), 
            false -> ~ Bernoulli(0.6)}, x);
\end{blogcode}

With this comprehension, we can even declare a conditional mixture of Gaussians easily. For example:
\begin{blogcode}
random Integer z ~ Categorical({0 -> 0.4, 1 -> 0.6});
random Real x ~ TabularCPD({0 -> ~Gaussian(5, 1.0), 
                 1 -> ~Gaussian(10, 1.0)}, z);
\end{blogcode}

\subsubsection{Multiple dependent variables}
To declare that a TabularCPD is dependent on several parent variables, use a multi-dimensional map:
\begin{blogcode}
TabularCPD({[0, 0] -> ~ Gaussian(5, 1.0), 
            [0, 1] -> ~ Gaussian(10, 1.0),
            [1, 0] -> ~ Gaussian(2, 4.0),
            [1, 1] -> ~ Gaussian(20, 4.0)}, [x, y])
\end{blogcode}

\hide{
\subsubsection{Tree conditionals}
If a CPD is based on a map from key to a TabularCPD, it will be a hierarchical \emph{tree conditional}. 
The following example will essentially construct the same distribution as above.
In general there can be multiple hierarchies.
}


\section{Extending \bl}
\subsection{User defined distribution}
Probability distributions are implemented in Java.  Distribution classes should implement the interface \verb|blog.distrib.CondProbDistrib|.
Alternatively, distributions can be declared as subclass of \verb|blog.distrib.AbstractCondProbDistrib|. 
By default, the \bl engine will look up distribution classes in the package \verb|blog.distrib|. In addition, it will look up distribution classes under the default empty package. 

{\bf Note}: using a distribution class to implement a deterministic operation is supported but not recommended. 

Below is one example of a uniform distribution on Integers.

\begin{minted}{java}
import java.util.*;
import blog.*;
import blog.distrib.*;
import blog.common.Util;
import blog.model.Type;

public class UniformInt extends AbstractCondProbDistrib {
  public UniformInt(List params) {
    try {
      lower = ((Number) params.get(0)).intValue();
      upper = ((Number) params.get(1)).intValue();
      if ((lower > upper) || (params.size() > 2)) {
        throw new IllegalArgumentException();
      }
    } catch (RuntimeException e) {
      throw new IllegalArgumentException(
          "UniformInt CPD expects two integer arguments "
              + "[lower, upper] with lower <= upper.  Got: " + params);
    }
  }

  public double getProb(List args, Object value) {
    if (!args.isEmpty()) {
      throw new IllegalArgumentException(
          "UniformInt CPD does not take any arguments.");
    }
    if (!(value instanceof Integer)) {
      throw new IllegalArgumentException(
          "UniformInt CPD defines distribution over objects of class "
              + "Integer, not " + value.getClass() + ".");
    }
    int x = ((Integer) value).intValue();

    if ((x >= lower) && (x <= upper)) {
      return 1.0 / (upper - lower + 1);
    }
    return 0;
  }

  public Object sampleVal(List args, Type childType) {
    if (!args.isEmpty()) {
      throw new IllegalArgumentException(
          "UniformInt CPD does not take any arguments.");
    }

    double x = lower + Math.floor(Util.random() * (upper - lower + 1));
    return new Integer((int) x);
  }

  private int lower;
  private int upper;
}
\end{minted}


\section{A comprehensive example}
\begin{example}[Hidden Markov models]
The following represents a hidden Markov model for genetic sequences with four states and four output symbols. The state at each time step transitions to another with respect to a conditional distribution specified by a TabularCPD. 
Each state at each time step emits an observation with respect to another CPD. After making a few observations, we can query the states for each time step.
\end{example}

\begin{blogcode}
type State;
distinct State A, C, G, T;
type Output;
distinct Output ResultA, ResultC, ResultG, ResultT;
random State S(Timestep t)
  if t == @0 then 
    ~ Categorical({A -> 0.3, C -> 0.2, G -> 0.1, T -> 0.4})
  else ~ TabularCPD(
    {A -> ~ Categorical({A -> 0.1, C -> 0.3, G -> 0.3, T -> 0.3}),
     C -> ~ Categorical({A -> 0.3, C -> 0.1, G -> 0.3, T -> 0.3}),
     G -> ~ Categorical({A -> 0.3, C -> 0.3, G -> 0.1, T -> 0.3}),
     T -> ~ Categorical({A -> 0.3, C -> 0.3, G -> 0.3, T -> 0.1})},
    S(prev(t)));

random Output O(Timestep t)
  ~ TabularCPD(
    {A -> ~ Categorical({ResultA -> 0.85, ResultC -> 0.05,
                         ResultG -> 0.05, ResultT -> 0.05}),
    C -> ~ Categorical({ResultA -> 0.05, ResultC -> 0.85, 
                        ResultG -> 0.05, ResultT -> 0.05}),
    G -> ~ Categorical({ResultA -> 0.05, ResultC -> 0.05, 
                        ResultG -> 0.85, ResultT -> 0.05}),
    T -> ~ Categorical({ResultA -> 0.05, ResultC -> 0.05, 
                        ResultG -> 0.05, ResultT -> 0.85})},
    S(t));

/* Evidence for the Hidden Markov Model.
 */
obs O(@0) = ResultC;
obs O(@1) = ResultA;
obs O(@2) = ResultA;
obs O(@3) = ResultA;
obs O(@4) = ResultG;

/* Queries for the Hidden Markov Model, given the evidence.  
 * Note that we can query S(5) even though our observations 
 * only went up to time 4.
 */
query S(@0);
query S(@1);
query S(@2);
query S(@3);
query S(@4);
query S(@5);
\end{blogcode}
%\subsection{Observability}


%\appendixpage
\appendix
%\appendixpage
%\addappheadtotoc
%\begin{appendices}
\phantomsection
\addcontentsline{toc}{section}{\appendixtocname}

%\cleardoublepage


\section{A Brief  History of BLOG}
Bayesian Logic (BLOG) was first developed by Brian Milch in 2005. Since then, major contribution is from various members of Professor Stuart Russell's research group at University of California Berkeley. 

The initial syntax and semantics of \bl was described in 

\begin{quote}
Brian Milch, Bhaskara Marthi, Stuart Russell, David Sontag, Daniel L. Ong, and Andrey Kolobov (2005) "BLOG: Probabilistic Models with Unknown Objects". Proc. 19th International Joint Conference on Artificial Intelligence (IJCAI): 1352-1359.
\end{quote}

Dr. Rodrigo Braz introduced Timestep into BLOG. Milch and Braz released \bl 0.3 in 2008.

Dr. Lei Li has been leading the development of the language and \bl inference system since 2011. Since then, the language sees major changes, as well as the inference engine. New algorithms are introduced. However, the semantics of \bl remain the same as the original. 

\section{\bl Grammar Definition}

\begin{verbatim}
blog_program ::= opt_statement_lst;

opt_statement_lst ::= /* EMPTY */ 
  | statement_lst;

statement_lst ::= statement:e statement_lst
  | statement;

statement ::= declaration_stmt 
  | evidence_stmt 
  | query_stmt ;

declaration_stmt ::= type_decl
  | fixed_func_decl
  | rand_func_decl
  | origin_func_decl 
  | number_stmt 
  | distinct_decl 
  | parameter_decl 
  | distribution_decl ;

type_decl ::= TYPE ID SEMI ;

type ::= refer_name
  | array_type ;

array_type_or_sub ::= refer_name LBRACKET ;

array_type ::= array_type_or_sub RBRACKET
  | array_type LBRACKET RBRACKET ;

opt_parenthesized_type_var_lst ::= /* EMPTY */
  | LPAREN RPAREN
  | LPAREN type_var_lst RPAREN ;

type_var_lst ::= type ID COMMA type_var_lst
  | type ID ;

fixed_func_decl ::=
    FIXED type ID opt_parenthesized_type_var_lst 
    EQ expression SEMI ;

rand_func_decl ::=
    RANDOM type ID opt_parenthesized_type_var_lst 
    dependency_statement_body SEMI ;

number_stmt ::=
    NUMSIGN refer_name opt_parenthesized_origin_var_list
    dependency_statement_body SEMI;

opt_parenthesized_origin_var_list ::= /* EMPTY */
  | LPAREN origin_var_list RPAREN ;

origin_var_list ::= ID EQ ID COMMA origin_var_list
  | ID EQ ID ;

origin_func_decl ::= 
    ORIGIN type ID LPAREN type RPAREN SEMI ;

distinct_decl ::=
    DISTINCT refer_name id_or_subid_list SEMI ;

id_or_subid_list ::= id_or_subid
  | id_or_subid COMMA id_or_subid_list ;

id_or_subid ::= ID
  | ID LBRACKET INT_LITERAL RBRACKET ;

distribution_decl ::=
    DISTRIBUTION ID EQ refer_name
    LPAREN opt_expression_list RPAREN SEMI ;

refer_name ::= ID
  | ID DOT refer_name ;

dependency_statement_body ::= EQ expression
  | distribution_expr
  | IF expression THEN dependency_statement_body elseif_list ;

elseif_list ::= /* EMPTY */
  | ELSE dependency_statement_body ;

parameter_decl ::= PARAM type ID SEMI
  | PARAM type ID COLON expression SEMI ;

expression ::= operation_expr
  | distribution_expr
  | literal
  | function_call
  | list_construct_expression
  | map_construct_expression
  | quantified_formula
  | set_expr
  | number_expr
  | refer_name ;

literal ::= STRING_LITERAL
  | CHAR_LITERAL
  | INT_LITERAL
  | DOUBLE_LITERAL
  | BOOLEAN_LITERAL
  | NULL ;

operation_expr ::= expression PLUS expression
  | expression MINUS expression
  | expression MULT expression
  | expression DIV expression
  | expression MOD expression
  | expression POWER expression
  | expression LT expression
  | expression GT expression
  | expression LEQ expression
  | expression GEQ expression
  | expression EQEQ expression
  | expression NEQ expression
  | expression AND expression
  | expression OR expression
  | expression DOUBLERIGHTARROW expression
  | expression LBRACKET expression RBRACKET
  | array_type_or_sub expression RBRACKET
  | unary_operation_expr ;

unary_operation_expr ::= MINUS expression
  | NOT expression
  | AT expression
  | LPAREN expression RPAREN ;

quantified_formula ::= 
    FORALL type ID expression
  | EXISTS type ID expression ;

function_call ::= 
    refer_name LPAREN opt_expression_list RPAREN ;

distribution_expr ::= 
    DISTRIB refer_name LPAREN opt_expression_list RPAREN;

opt_expression_list ::= /* EMPTY */
  | expression_list ;

expression_list ::= expression COMMA expression_list
  | expression ;

list_construct_expression ::= 
    LBRACKET opt_expression_list RBRACKET
  | LBRACKET semi_colon_separated_expression_list RBRACKET ;

semi_colon_separated_expression_list ::=
    expression_list SEMI semi_colon_separated_expression_list
  | expression_list SEMI expression_list ;

map_construct_expression ::= 
    LBRACE expression_pair_list RBRACE ;

expression_pair_list ::=
    expression RIGHTARROW expression COMMA expression_pair_list
  | expression RIGHTARROW expression ;
  
number_expr ::= NUMSIGN set_expr
  | NUMSIGN type ;

set_expr ::= explicit_set
  | implicit_set
  | tuple_set ;

explicit_set ::= LBRACE opt_expression_list RBRACE ;

implicit_set ::= 
    LBRACE type ID COLON expression RBRACE
  | LBRACE type ID RBRACE ;

tuple_set ::= 
    LBRACE expression_list 
    FOR type_var_lst COLON expression RBRACE
  | LBRACE expression_list FOR type_var_lst RBRACE ;

evidence_stmt ::= OBS evidence SEMI ;

evidence ::= symbol_evidence
  | value_evidence ;

value_evidence ::= expression EQ expression ;

symbol_evidence ::= implicit_set EQ explicit_set ;

query_stmt ::= QUERY query SEMI ;

query ::= expression ;
\end{verbatim}


\section{Built-in operators and functions}
\begin{table}[H]
\centering
\caption{Arithmetic operators on Integer and Real}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
\verb|+| & plus & \verb|x + y| , \verb|1.0 + 2|\\ 
\verb|-| & minus & \verb|x - y| , \verb|1.0 - 2|\\ 
\verb|*| & multiply & \verb|x * y| , \verb|1.0 * 2|\\
\verb|/| & divide & \verb|x / y| , \verb|1.0 / 2|\\ 
\verb|%| & modulus (only applied to Integers) & \verb|x % y|, \verb|1.0 % 2| \\
\verb|^| & power & \verb|x ^ y| , \verb|1.0 ^ 2| \\
\verb|abs| & absolute value & \verb|abs(x)|,  \verb|abs(-1.0)| \\
\verb|round| & rounding & \verb|round(x)|,  \verb|round(1.6)| \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Operators on RealMatrix
\label{tab:matrixop}
}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
\verb|+| & plus & \verb|x + y| \\ 
\verb|-| & minus & \verb|x - y| \\ 
\verb|*| & multiply & \verb|x * y| \\
\verb|inv| & inverse & \verb|inv(x)| \\
\verb|transpose| & transpose & \verb|transpose(x)| \\
\verb|det| & determinant & \verb|det(x)| \\
\verb|repmat| & repeat a matrix & \verb|repmat(x, 2, 3)| \\
\verb|diag| & create a diagonal matrix & \verb|diag(x)| \\
\verb|vstack| & stacking scalars or matrices to create a larger one & \verb|vstack(x, y, z)| \\
\verb|hstack| & horizontally stacking scalars or matrices & \verb|hstack(x, y, z)| \\
\verb|eye| & identity matrix & \verb|eye(3)| \\
\verb|zeros| & zero matrix & \verb|zeros(3, 4)| \\
\verb|ones| & a matrix with all 1 & \verb|ones(3, 4)| \\
\verb|exp| & element-wise exponential  & \verb|exp(x)| \\
\bottomrule
\end{tabular}

Note the dimensionality should match. 
\end{table}

\begin{table}[H]
\centering
\caption{Conversion between types
\label{tab:matrixop}
}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
\verb|toReal| & single element matrix, a number or Boolean into Real & \verb|toReal(x)| \\
\verb|toInt| & single element matrix, a number or Boolean into Int & \verb|toInt(x)| \\
\bottomrule
\end{tabular}
\end{table}



\begin{table}[H]
\centering
\caption{Logical operators on Boolean}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
\verb|&| & and & \verb|x & y| , \verb|(x > 3) & (x < 5)| \\ 
{\tt |} & or & \verb\x | y\ , \verb\(x > 5) | (x < 3)\ \\ 
{\tt !} & not & \verb|! x| , \verb|! (x > 3)| \\
{\tt =>} & imply & \verb|x => y| , \verb|(x > 5) => (x > 3)| \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Quantified formula}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
{\tt forall} & $\forall$ & \verb|forall Person x height(x) > 1.0| \\ 
{\tt exists} & $\exists$ & \verb|exists Person x height(x) > 1.0|  \\ 
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Relational operators on Integer, Real and other comparable types}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
{\tt >} & greater than & \verb|a > b| ,  \verb|2 > 1.0|\\ 
{\tt >=} & greater than or equal to & \verb|a >= b| ,  \verb|2 >= 1.0| \\ 
{\tt <} & less than & \verb|a < b| ,  \verb|1.0 < 2.0| \\
{\tt <=} & less than or equal to & \verb|a <= b| ,  \verb|1.0 <= 2.0|  \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Equality operator on all types}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
{\tt ==} & equal to & \verb|a == b|   \\ 
{\tt !=} & unequal to & \verb|a != b|  \\ 
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Operators on String}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
{\tt +} & concatenate & \verb|"hello " + "world"|  \\ 
{\tt ==} & equal to & \verb|"abc" == "def"|  \\
{\tt !=} & unequal to & \verb|"abc" != "def"|\\ 
\verb|IsEmptyString()| & returns True if the string is empty & \verb|IsEmptyString(a)| \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Operators on Timestep}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
\verb|prev()| & previous Timestep & \verb|prev(@1)|  \\
\verb|-| & Timestep minus an integer & \verb|@10 - 1 == @9|  \\
\verb|+| & Timestep plus an integer & \verb|@10 + 1 == @11|  \\
\verb|%| &  Timestep mod & \verb|x % 10 == @0|  \\
\verb|*| & Timestep multiply an integer & \verb|@10 * 2 == @20|  \\
\verb|/| & Timestep divide an integer & \verb|@10 / 2 == @5|  \\
\bottomrule
\end{tabular}
\end{table}

\begin{table}[H]
\centering
\caption{Arithmetic operators on Set}
\begin{tabular}{ c c c }
\toprule 
operator & interpretation & example \\
\midrule
\verb|min| & minimum of elements a set & \verb|min()|\\ 
\verb|max| & maximum of elements in a set & \verb|max()|\\
\verb|sum| & summation of elements in a set & \verb|sum()|\\ 
\bottomrule
\end{tabular}
\end{table}

\section{Built-in distributions}
\begin{itemize*}
\item Bernoulli(p), with probability of $p$ generating 1, and $1-p$ generating 0.
\item Beta($\alpha$, $\beta$), generating a real number $x$ in [0,1] with probability density of $\frac{x^{\alpha - 1} (1-x)^{\beta - 1}}{B(\alpha, \beta)}$, where Beta function $B$ is the normalization constant to ensure the total probability integrates to 1.
\item Binomial(n, p)  
\item BooleanDistrib(p), with probability of $p$ generating \verb|True|, and $1-p$ generating \verb|False|.
\item Categorical
\item Dirichlet
\item Exponential
\item Gamma
\item Gaussian
\item Geometric
\item Iota
\item Laplace
\item LinearGaussian
\item Multinomial
\item MultivarGaussian
\item NegativeBinomial
\item Poisson($\lambda$), generating an integer $x$ with probability $\frac{\lambda^x}{x!}e^{-\lambda}$.
\item Size($S$), deterministically returns the number of elements in the given set $S$.
\item TabularCPD
\item UniformChoice($S$), uniformly choosing one element from the given set $S$.
\item UniformInt
\item UniformReal
\item UniformVector
\end{itemize*}

\begin{table}[H]
\centering
\caption{Distributions in \bl}
\begin{tabular}{ c c c p{2in} }
\toprule 
distribution & argument type & value  & example \\ 
 \midrule
Bernoulli & Real in [0,1] & binary 0/1 & \verb|Bernoulli(0.8)| \\ 
Beta & Real, Real & Real in [0,1] & \verb|Beta(1.0, 1.0)| \\ 
Binomial & Integer, Real & Integer & \verb|Binomial(10, 0.5)| \\ 
BooleanDistrib & Real in [0,1] & Boolean & \verb|BooleanDistrib(0.8)| \\ 
Categorical & Map & & see main text \\
Dirichlet & Array of Real & Array of Real & \verb|Dirichlet([1, 1, 1])| \\
Exponential & Real & Real & \verb|Exponential(2.0)| \\ 
Gamma & Real, Real & Real & \verb|Gamma(3, 2.0)| \\ 
Gaussian & Real, Real & Real & \verb|Gaussian(2.0, 1.0)| \\ 
Geometric & Real in [0,1] & nonnegative Integer & \verb|Geometric(0.5)| \\ 
Laplace & Real, and positive Real & Real & \verb|Laplace(0, 1.0)| \\ 
MultivarGaussian & Array, 2D Array & Array of Real & \verb|MultivarGaussian([0, 0],| \verb| [1, 0; 0, 1])| \\
NegativeBinomial & Integer, Real in [0,1] & Integer & \verb|NegativeBinomial(4, 0.5)| \\ 
Poisson & Real & nonnegative Integer & \verb|Poisson(6.0)| \\ 
UniformChoice & Set &  & \verb|UniformChoice({Person p})| \\
UniformInt & Integer, Integer & Integer & \verb|UniformInt(0, 10)| \\
UniformReal & Real, Real & Real & \verb|UniformReal(0, 1.0)| \\
UniformVector & Real's & RealMatrix & \verb|UniformVector(0,1,0,1)| \\
 \bottomrule
\end{tabular} 
\end{table}


\optional{

\section{Query and inference guidance}

\section{Parameters}
A parameter is only declared but not initialized with a particular value. Its value can be learned in the inference engine. To declare a parameter
\begin{blogcode}
param type1 name(type2, ...);
param type1 name(type2, ...) : condition;
\end{blogcode} 
This declares a parameter that should satisfy the optional condition. \texttt{condition} is a nonrandom expression that returns a Boolean value. 

Note here a parameter can be a function with argument of \texttt{type2, ...}, with the restriction that \texttt{type2, ...} should only involve types with distinct statements and number statements on nonrandom expression or param.
\reminder{a bit ugly}. 

Learnable parameters can be used in complex expressions. For example:
\begin{blogcode}
param Real a;
random Real x ~ Gaussian(2 ^ a, 1.0);
random Real y ~ Gaussian(a, 1.0);
\end{blogcode}

We could specifying the range of a parameter, for example:
\begin{blogcode}
param Real a: 0 < a & a < 10;
param Real b: b > 1;
random Real x ~ Gaussian(a, b);
\end{blogcode}

Commonly used parameters are often without arguments. However, the syntax does not prevent specifying infinite parameters like:
\begin{blogcode}
param Real mu(Int);
\end{blogcode}

%\hide{
\subsection {Array of Parameters}
We could define an array of parameters using
\begin{blogcode}
param type[size] name;
\end{blogcode}
where {\tt size} should be a constant natural number.

\begin{blogcode}
param Real[10] theta;
\end{blogcode}

\subsection{Declaring number param}
\reminder{Seems this will create problem to the EM algorithm}
A special case of parameter would the number statement. For example,
\begin{blogcode}
type Person;
param NaturalNum #Person;
param Real TrueHeight(Person p) : TrueHeight(p) > 0;
random Real MeasuredHeight(Person p) ~ Gaussian(TrueHeight(p), 1.0);
\end{blogcode}
We will describe the notation for distributions in Section~\ref{sec:distribution}. For the moment, we use Gaussian as a notation for Gaussian distributions.
This example defines a set of parameters, and its size itself is a parameter.

Note that since \texttt{TrueHeight} takes \texttt{Person} as an argument, we should not allow \texttt{\#Person} to be generated from a random distribution.
haha
%}

\section{User defined distribution}
\reminder{TO-DO, how to define pdf and sampling function?}

\section{Import user libraries}
\subsection{Import blog program}
\begin{blogcode}
import path;
\end{blogcode}
Where \texttt{path} is a java style package description.

For example, to import urn-ball.blog:
\begin{blogcode}
import urn-ball;
\end{blogcode}

\subsection{Referring to external library}
\begin{blogcode}
extern blog.distribution.*;
\end{blogcode}
It will make all implementation of Distribution visible to blog inference engine.


\section{Variable size array}
The size of an array is usually a constant. However it can also be random value.
For example:
\begin{blogcode}
random NaturalNum n ~ Poisson(10.0) + 1;
random Real[n] x;
\end{blogcode}


\section{Reference to Distribution}
If a distribution is referred in a \emph{general expression}, it is regarded as a random variable and will take a sample as the value.
For example, 
\begin{blogcode}
random Real x = 1 + Gaussian(0, 1.0);
\end{blogcode}
It has the same semantics as
\begin{blogcode}
random Real y ~ Gaussian(0, 1.0);
random Real x = 1 + y;
\end{blogcode}
\texttt{\~{}} is used when the right side is a distribution, while \texttt{=} is used when the right side is a general expression. 
\reminder{Shaunak suggests using \texttt{=} primarily, and \texttt{\~{}} only in certain cases that are not clear from context.}
}

%\end{appendices}

\end{document}
